diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
index 0a54a8e..77ca595 100644
--- a/arch/arm64/kernel/head.S
+++ b/arch/arm64/kernel/head.S
@@ -114,10 +114,7 @@ pe_header:
 	 *  x19/x20    __primary_switch()         callee preserved temp registers
 	 */
 ENTRY(stext)
-	mov	x0, #0x08000000
-//	mov	x4, #0x40007fc0
 	bl	preserve_boot_args
-	bl	el3_setup			// Drop to EL2, w0=cpu_boot_mode
 	bl	el2_setup			// Drop to EL1, w0=cpu_boot_mode
 	adrp	x23, __PHYS_OFFSET
 	and	x23, x23, MIN_KIMG_ALIGN - 1	// KASLR offset, defaults to 0
@@ -463,50 +460,6 @@ ENDPROC(__primary_switched)
 ENTRY(kimage_vaddr)
 	.quad		_text - TEXT_OFFSET
 
-ENTRY(el3_setup)
-	msr	SPsel, #1			// We want to use SP_EL{1,2}
-	mrs	x0, CurrentEL
-	cmp	x0, #CurrentEL_EL3
-	b.eq	1f
-	mov_q	x0, (SCTLR_EL1_RES1 | ENDIAN_SET_EL1)
-	msr	sctlr_el1, x0
-	mov	w0, #BOOT_CPU_MODE_EL1		// This cpu booted in EL1
-	isb
-	ret
-
-// Initialize SCTLR_EL2 and HCR_EL2 to save values before entering EL2.
-1:	MSR	SCTLR_EL2, XZR
-	MSR	HCR_EL2, XZR
-// Determine the EL2 Execution state.
-	MRS	X0, SCR_EL3
-	ORR	X0, X0, #(1<<10) // RW EL2 Execution state is AArch64.
-	ORR	X0, X0, #(1<<0) // NS EL1 is Non-secure world.
-	MSR	SCR_EL3, x0
-	MOV	X0, #0b01001 // DAIF=0000
-	MSR	SPSR_EL3, X0 // M[4:0]=01001 EL2h must match SCR_EL3.RW
-// Determine EL2 entry.
-	ADR	X0, el2_entry // el2_entry points to the first instruction of
-	MSR	ELR_EL3, X0 // EL2 code.
-	ERET
-
-el2_entry:
-// Initialize the SCTLR_EL1 register before entering EL1.
-	MSR	SCTLR_EL1, XZR
-// Determine the EL1 Execution state.
-	MRS	X0, HCR_EL2
-	ORR	X0, X0, #(1<<31) // RW=1 EL1 Execution state is AArch64.
-	MSR	HCR_EL2, X0
-	MOV	X0, #0b00101 // DAIF=0000
-	MSR	SPSR_EL2, X0 // M[4:0]=00101 EL1h must match HCR_EL2.RW.
-	ADR	X0, el1_entry // el1_entry points to the first instruction of
-	MSR	ELR_EL2, X0 // EL1 code.
-	ERET
-
-el1_entry:
-	ret
-
-ENDPROC(el3_setup)
-
 /*
  * If we're fortunate enough to boot at EL2, ensure that the world is
  * sane before dropping to EL1.
