From 0bbec9a12a71103abe94eeada103e384e1acf3fd Mon Sep 17 00:00:00 2001
From: Canh Dao <canh.dao.ct@renesas.com>
Date: Thu, 12 Aug 2021 17:21:56 +0700
Subject: [PATCH] enabled usb-xhci and i2c

Signed-off-by: Canh Dao <canh.dao.ct@renesas.com>
---
 .../dts/renesas/r9a09g011gbg-evaluation-board.dts  |  66 +++
 arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi      |  67 +++
 arch/arm64/configs/defconfig                       |   4 +-
 drivers/i2c/busses/Kconfig                         |  11 +
 drivers/i2c/busses/Makefile                        |   1 +
 drivers/i2c/busses/i2c-rzv2m.c                     | 650 +++++++++++++++++++++
 drivers/usb/gadget/udc/renesas_usb3.c              |   2 +-
 drivers/usb/host/Kconfig                           |  24 +
 drivers/usb/host/Makefile                          |   4 +
 drivers/usb/host/xhci-plat.c                       |  13 +-
 drivers/usb/host/xhci-rzv2m.c                      | 131 +++++
 drivers/usb/host/xhci-rzv2m.h                      |  30 +
 12 files changed, 999 insertions(+), 4 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-rzv2m.c
 create mode 100755 drivers/usb/host/xhci-rzv2m.c
 create mode 100755 drivers/usb/host/xhci-rzv2m.h

diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
index 330cb21..6e58098 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
@@ -102,3 +102,69 @@
 	timeout-sec = <60>;
 };
 #endif
+
+#if 0
+&usb2_phy0 {
+/*     pinctrl-0 = <&usb0_pins>;*/
+/*     pinctrl-names = "default";*/
+
+       status = "okay";
+};
+#endif
+
+&xhci0 {
+/*     pinctrl-0 = <&usb30_pins>;*/
+/*     pinctrl-names = "default";*/
+
+       status = "okay";
+};
+
+#if 0
+&usb3_peri0 {
+//     companion = <&xhci0>;
+
+       status = "okay";
+       renesas,usb-role-switch;
+
+       port {
+               #address-cells = <1>;
+               #size-cells = <0>;
+
+               usb3peri_role_switch: endpoint@0 {
+                       reg = <0>;
+                       remote-endpoint = <&hd3ss3220_ep>;
+               };
+       };
+};
+#endif
+
+#if 0
+&i2c0 {
+       status = "okay";
+       clock-frequency = <100000>;
+
+       hd3ss3220@47 {
+               compatible = "ti,hd3ss3220";
+               reg = <0x47>;
+/*             interrupt-parent = <&gpio6>;*/
+/*             interrupts = <3 IRQ_TYPE_LEVEL_LOW>;*/
+
+               usb_con: connector {
+                       compatible = "usb-c-connector";
+                       label = "USB-C";
+                       data-role = "dual";
+               };
+
+               port {
+                       #address-cells = <1>;
+                       #size-cells = <0>;
+
+                       hd3ss3220_ep: endpoint@0 {
+                               reg = <0>;
+                               remote-endpoint = <&usb3peri_role_switch>;
+                       };
+               };
+       };
+};
+#endif
+
diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
index ddb88d9..bbe361d 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
@@ -16,6 +16,7 @@
 
 	aliases {
 		ethernet0 = &avb;
+                i2c0 = &i2c0;
 	};
 
 #if 0
@@ -139,6 +140,17 @@
 		compatible = "fixed-clock";
 		clock-frequency = <200000000>;
 	};
+        pclk: pclk@100M {
+                #clock-cells = <0>;
+                compatible = "fixed-clock";
+                clock-frequency = <100000000>;
+        };
+ 
+        usbclk: usbclk@200M {
+                #clock-cells = <0>;
+                compatible = "fixed-clock";
+                clock-frequency = <200000000>;
+        };
 #endif
 
 	soc: soc {
@@ -185,6 +197,61 @@
 		};
 #endif
 
+               i2c0: i2c@a4030000 {
+                       #address-cells = <1>;
+                       #size-cells = <0>;
+                       compatible = "renesas,rzv2m-i2c";
+                       reg = <0 0xa4030000 0 0x80>;
+                       interrupts = <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>,<GIC_SPI 236 IRQ_TYPE_LEVEL_HIGH>;
+                       clocks = <&pclk>;
+       /*              power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+       /*              resets = <&cpg 931>;*/
+       /*              dmas = <&dmac1 0x91>, <&dmac1 0x90>,*/
+       /*                     <&dmac2 0x91>, <&dmac2 0x90>; */
+       /*              dma-names = "tx", "rx", "tx", "rx"; */
+                       i2c-scl-internal-delay-ns = <110>;
+                       status = "disabled";
+               };
+
+               xhci0: usb@85060000 {
+                       compatible = "renesas,xhci-r8a774c0",
+                                    "renesas,rzv2m-xhci";
+                       reg = <0 0x85060000 0 0x20000>;
+                       interrupts = <GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>;
+                       clocks =  <&usbclk>;
+                       /*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+                       /*resets = <&cpg 328>;*/
+                       status = "disabled";
+               };
+#if 0
+               usb3_peri0: usb@85070000 {
+                       compatible = "renesas,r8a774c0-usb3-peri",
+                                    "renesas,rcar-gen3-usb3-peri";
+                       reg = <0 0x85070000 0 0x1000>;
+
+                       interrupts = <GIC_SPI 242 IRQ_TYPE_LEVEL_HIGH>,
+                                    <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH>,
+                                    <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>,
+                                    <GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>;
+                       clocks =  <&usbclk>;
+                       /*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;
+                        resets = <&cpg 328>;*/
+                       status = "disabled";
+               };
+#endif
+#if 0
+               usb2_phy0: usb-phy@85070200 {
+                       compatible = "renesas,usb2-phy-r8a774c0",
+                                    "renesas,rcar-gen3-usb2-phy";
+                       reg = <0 0x85070200 0 0x700>;
+                       interrupts = <GIC_SPI 242 IRQ_TYPE_LEVEL_HIGH>,
+                                    <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH>,
+                                    <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>;
+                       clocks =  <&usbclk>;
+                       status = "disabled";
+               };
+#endif
+
 #if 1 /* used sh card boot */
 		sdhi0: sd@85000000 {
 			compatible = "renesas,sdhi-r8a774c0",
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 73e19f0..76ea1b7 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -153,7 +153,8 @@ CONFIG_I2C_MUX=y
 CONFIG_I2C_MUX_PCA954x=y
 CONFIG_I2C_DESIGNWARE_PLATFORM=y
 CONFIG_I2C_SH_MOBILE=y
-CONFIG_I2C_RCAR=y
+#CONFIG_I2C_RCAR=y
+CONFIG_I2C_RZV2M=y
 CONFIG_SPI=y
 CONFIG_SPI_SPIDEV=y
 CONFIG_SPI_SH_MSIOF=y
@@ -288,6 +289,7 @@ CONFIG_USB_RENESAS_USBHS_UDC=y
 CONFIG_USB_RENESAS_USB3=y
 CONFIG_USB_SNP_UDC_PLAT=y
 CONFIG_USB_BDC_UDC=y
+CONFIG_USB_XHCI_RZV2M=y
 CONFIG_TYPEC=y
 CONFIG_TYPEC_HD3SS3220=y
 CONFIG_USB_MASS_STORAGE=m
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 017aec3..e0f8d53 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -1125,6 +1125,17 @@ config I2C_RCAR
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-rcar.
 
+config I2C_RZV2M
+       tristate "Renesas RZ/V2M I2C Controller"
+       depends on ARCH_RENESAS || COMPILE_TEST
+       help
+         If you say yes to this option, support will be included for the
+         RZ/V2M I2C controller.
+
+         This driver can also be built as a module.  If so, the module
+         will be called i2c-rzv2m.
+
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_DIOLAN_U2C
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 18b26af..6049ea6 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -126,6 +126,7 @@ obj-$(CONFIG_I2C_ROBOTFUZZ_OSIF)	+= i2c-robotfuzz-osif.o
 obj-$(CONFIG_I2C_TAOS_EVM)	+= i2c-taos-evm.o
 obj-$(CONFIG_I2C_TINY_USB)	+= i2c-tiny-usb.o
 obj-$(CONFIG_I2C_VIPERBOARD)	+= i2c-viperboard.o
+obj-$(CONFIG_I2C_RZV2M)         += i2c-rzv2m.o
 
 # Other I2C/SMBus bus drivers
 obj-$(CONFIG_I2C_ACORN)		+= i2c-acorn.o
diff --git a/drivers/i2c/busses/i2c-rzv2m.c b/drivers/i2c/busses/i2c-rzv2m.c
new file mode 100644
index 0000000..9438468
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rzv2m.c
@@ -0,0 +1,650 @@
+/*
+ * Driver for the Renesas RZ/V2M I2C unit
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+
+/* Register offsets */
+#define IICB0DAT	0x00	/* Data Register */
+#define IICB0SVA	0x04	/* Slave Address Register */
+#define IICB0CTL0	0x08	/* Control Register 0 */
+#define IICB0TRG	0x0C	/* Trigger Register */
+#define IICB0STR0	0x10	/* Status Register 0 */
+#define IICB0STR1	0x14	/* Status Register 1 */
+#define IICB0STRC	0x18	/* Status Clear Register */
+#define IICB0CTL1	0x20	/* Control Register 1 */
+#define IICB0WL		0x24	/* Low Level Width Setting Register */
+#define IICB0WH		0x28	/* How Level Width Setting Register */
+
+
+/* IICB0CTL0 8bit*/
+#define IICB0IICE	(1 << 7)	/* I2C Enable */
+#define IICB0MDTX1	(1 << 4)	/* Transfer Mode(Slave) */
+#define IICB0MDTX0	(1 << 3)	/* Transfer Mode(Master) */
+#define IICB0SLSI	(1 << 2)	/* IICBTIS Signal Enable */
+#define IICB0SLWT	(1 << 1)	/* Interrupt Request Timing */
+#define IICB0SLAC	(1 << 0)	/* Acknowledge */
+
+/* IICB0TRG 8bit */
+#define IICB0LRET	(1 << 3)	/* Communication to Wait Trigger */
+#define IICB0WRET	(1 << 2)	/* Quit Wait Trigger */
+#define IICB0STT	(1 << 1)	/* Create Start Condition Trigger */
+#define IICB0SPT	(1 << 0)	/* Create Stop Condition Trigger */
+
+/* IICB0STR0 16bit-access only */
+#define IICB0SSMS	(1 << 15)	/* Master Flag : 1: work or 0: not */
+#define IICB0SSDR	(1 << 13)	/* IICB0DAT Flag (No Care) */
+#define IICB0SSWT	(1 << 12)	/* Wait Flag */
+#define IICB0SSEX	(1 << 11)	/* Extend Code Flag */
+#define IICB0SSCO	(1 << 10)	/* Address Match Flag  */
+#define IICB0SSTR	(1 << 9)	/* Send Flag */
+#define IICB0SSAC	(1 << 8)	/* Ack Flag */
+#define IICB0SSRS	(1 << 7)	/* Communication Reserve Flag */
+#define IICB0SSBS	(1 << 6)	/* Bus Flag */
+#define IICB0SSST	(1 << 5)	/* Start Condition Flag */
+#define IICB0SSSP	(1 << 4)	/* Stop Condition Flag */
+#define IICB0STCF	(1 << 1)	/* IICB0TRG.IICB0STT Clear Flag */
+#define IICB0ALDF	(1 << 0)	/* Arbitration Fall Flag (No Care) */
+
+/* IICB0CTL1 8bit*/
+#define IICB0MDSC	(1 << 7)	/* Bus Mode */
+#define IICB0LGDF	(1 << 4)	/* Digital filter */
+#define IICB0MDLB	(1 << 3)	/* Loop-back mode */
+#define IICB0SLSE	(1 << 1)	/* Start condition output */
+#define IICB0SLRS	(1 << 0)	/* Disable Communication Reserve */
+
+/* Baudrate calulate */
+#define RZV2M_I2C_TWODIGIT	100	/* 2-digit decimal to integer */
+#define RZV2M_I2C_NINEDIGIT	1000000000/* 9-digit decimal to integer */
+
+/* RZ/V2M I2C struct */
+struct rzv2m_i2c_priv {
+	void __iomem *base;
+	struct i2c_adapter adap;
+	struct clk *clk;
+	int bus_mode;
+	struct completion msg_tia_done;
+	u16 iicb0wl;
+	u16 iicb0wh;
+};
+
+/* Transfer speed index*/
+enum bcr_index {
+	RZV2M_I2C_BCR_100K = 0,
+	RZV2M_I2C_BCR_400K,
+};
+
+/* Config */
+struct bcr_cfg {
+	int lcoeff;
+	int hcoeff;
+	int hdtim;
+};
+
+/* Config table */
+static const struct bcr_cfg bcr_cfg_table[] = {
+	{47, 53, 3450},
+	{52, 48, 900},
+};
+
+/* This function support to access write 32bit */
+static void rzv2m_i2c_write(struct rzv2m_i2c_priv *priv, u32 val, int reg)
+{
+	writel(val, priv->base + reg);
+}
+
+/* This function support to access read 32bit */
+static u32 rzv2m_i2c_read(struct rzv2m_i2c_priv *priv, int reg)
+{
+	return readl(priv->base + reg);
+}
+
+/* Tia interrupt callback */
+static irqreturn_t rzv2m_i2c_tia_irq_handler(int this_irq, void *dev_id)
+{
+	struct rzv2m_i2c_priv *priv = dev_id;
+
+	/* Set flag */
+	complete(&priv->msg_tia_done);
+
+	return IRQ_HANDLED;
+}
+
+/* Caluate IICB0WL and IICB0WH by clock */
+static int rzv2m_i2c_clock_calculate(struct device *dev,
+			struct rzv2m_i2c_priv *priv)
+{
+	const struct bcr_cfg *sbcr_cfg;
+
+	unsigned long input_rate;
+	u32 bus_clk_rate, scl_rise_ns, scl_fall_ns, sum;
+	u64 div;
+	u64 iicb0wl_temp, iicb0wh_temp;
+	int temp;
+
+	/* Get input clock:PCLK */
+	input_rate = clk_get_rate(priv->clk);
+
+	/* Get the bus rate property from dts */
+	if (of_property_read_u32(dev->of_node, "clock-frequency",
+						&bus_clk_rate)) {
+		dev_warn(dev,
+			 "Could not read clock-frequency property, Instead,100K is be to set\n");
+		bus_clk_rate = 100000;
+	}
+
+	if (of_property_read_u32(dev->of_node, "i2c-scl-rising-time-ns",
+						&scl_rise_ns))
+		scl_rise_ns = 0;
+
+	if (of_property_read_u32(dev->of_node, "i2c-scl-falling-time-ns",
+						&scl_fall_ns))
+		scl_fall_ns = 0;
+
+	sum = scl_rise_ns + scl_fall_ns;
+
+	/* Config setting */
+	switch (bus_clk_rate) {
+	case 400000:
+		sbcr_cfg = &bcr_cfg_table[RZV2M_I2C_BCR_400K];
+		priv->bus_mode = RZV2M_I2C_BCR_400K;
+		break;
+	case 100000:
+		sbcr_cfg = &bcr_cfg_table[RZV2M_I2C_BCR_100K];
+		priv->bus_mode = RZV2M_I2C_BCR_100K;
+		break;
+	default:
+		dev_err(dev, "transfer speed is invaild\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Caculate IICB0WL and IICBOWH by the following
+	 * IICB0WL = lcoeff / bus_clk * input_rate
+	 * IICB0WH = ( hcoeff / bus_clk  -tr -tf ) * input_rate
+	 */
+
+	/* IICB0WL */
+	/* Change order for compute calculation */
+	iicb0wl_temp = (u64)sbcr_cfg->lcoeff * input_rate;
+	/* The orginal lcoeff is two digits after the decimal point.
+	 * Thus divided by 100.
+	 */
+	div = bus_clk_rate * RZV2M_I2C_TWODIGIT;
+	if (iicb0wl_temp % div != 0)
+		iicb0wl_temp = iicb0wl_temp / div + 1;
+	else
+		iicb0wl_temp = iicb0wl_temp / div;
+
+	/*
+	 * Data hold time must be less than 0.9us in fast mode
+	 * and 3.45us in standard mode.
+	 * Data hold time = IICB0WL[9:2] / PCLK
+	 */
+	temp = (u64)(iicb0wl_temp >> 2) * RZV2M_I2C_NINEDIGIT / input_rate;
+	if (temp > sbcr_cfg->hdtim) {
+		dev_err(dev, "data hold time : %d[ns] is over the %d\n",
+			temp, sbcr_cfg->hdtim);
+		return -EINVAL;
+	}
+
+	/* IICB0WH */
+	iicb0wh_temp = (u64)input_rate * sbcr_cfg->hcoeff;
+
+	/* Round up */
+	if (iicb0wh_temp % div != 0)
+		iicb0wh_temp = iicb0wh_temp / div + 1;
+	else
+		iicb0wh_temp = iicb0wh_temp / div;
+
+	/* The unit ofsum is [ns] so that divied 10^9 */
+	iicb0wh_temp = iicb0wh_temp - (u64)sum * input_rate
+					/ RZV2M_I2C_NINEDIGIT;
+
+	/* Save IICB0WL IICB0WH setting */
+	priv->iicb0wl = (u16)iicb0wl_temp;
+	priv->iicb0wh = (u16)iicb0wh_temp;
+
+	return 0;
+}
+
+/* I2c init */
+static void rzv2m_i2c_init(struct rzv2m_i2c_priv *priv)
+{
+	u32 i2c_ctl0 = 0;
+	u32 i2c_ctl1 = 0;
+
+	/* i2c disable */
+    rzv2m_i2c_write(priv, 0, IICB0CTL0);
+
+	/* IICB0CTL1 setting */
+	i2c_ctl1 = (priv->bus_mode ? IICB0MDSC : 0)
+			 | IICB0SLSE;
+    rzv2m_i2c_write(priv, i2c_ctl1, IICB0CTL1);
+
+	/* IICB0WL IICB0WH setting */
+    rzv2m_i2c_write(priv, priv->iicb0wl, IICB0WL);
+    rzv2m_i2c_write(priv, priv->iicb0wh, IICB0WH);
+
+	/* i2c enable after setting */
+	i2c_ctl0 = IICB0SLWT | IICB0SLAC | IICB0IICE;
+    rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+}
+
+/* I2c write with ACK confirm*/
+static int rzv2m_i2c_write_with_ACK(struct rzv2m_i2c_priv *priv, u32 data)
+{
+	unsigned long time_left;
+
+	/* Flag clear*/
+	reinit_completion(&priv->msg_tia_done);
+
+	/* Write data */
+	rzv2m_i2c_write(priv, data, IICB0DAT);
+
+	/* Wait for transaction */
+	time_left = wait_for_completion_timeout(&priv->msg_tia_done,
+			priv->adap.timeout);
+	if (!time_left)
+		return -ETIMEDOUT;
+
+	/* Confirm ACK */
+	if ((rzv2m_i2c_read(priv, IICB0STR0) & IICB0SSAC) != IICB0SSAC)
+		return -ENXIO;
+
+	return 0;
+}
+
+/* I2c read with ACK confirm*/
+static int rzv2m_i2c_read_with_ACK(struct rzv2m_i2c_priv *priv, u8 *data, bool last)
+{
+	unsigned long time_left;
+	u32 i2c_ctl0;
+	u32 data_tmp;
+
+	/* Flag clear*/
+	reinit_completion(&priv->msg_tia_done);
+
+	/*  Interrupt request timing : 8th clock */
+	i2c_ctl0 = rzv2m_i2c_read(priv, IICB0CTL0);
+	i2c_ctl0 &= ~IICB0SLWT;
+    rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+
+	/* Exit the wait state */
+    rzv2m_i2c_write(priv, IICB0WRET, IICB0TRG);
+
+	/* Wait for transaction */
+	time_left = wait_for_completion_timeout(&priv->msg_tia_done,
+				priv->adap.timeout);
+	if (!time_left)
+		return -ETIMEDOUT;
+
+	if (!last) {/* Not last */
+		/* Read data */
+		data_tmp = rzv2m_i2c_read(priv, IICB0DAT);
+	} else { /* Last */
+		/* Disable ACK */
+		i2c_ctl0 = rzv2m_i2c_read(priv, IICB0CTL0);
+		i2c_ctl0 &= ~IICB0SLAC;
+        rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+
+		/* Read data*/
+		data_tmp = rzv2m_i2c_read(priv, IICB0DAT);
+
+		/* Interrupt request timing : 9th clock */
+		i2c_ctl0 = rzv2m_i2c_read(priv, IICB0CTL0);
+		i2c_ctl0 |= IICB0SLWT;
+        rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+
+		/* Exit the wait state */
+        rzv2m_i2c_write(priv, IICB0WRET, IICB0TRG);
+
+		/* Wait for transaction */
+		time_left = wait_for_completion_timeout(&priv->msg_tia_done,
+					priv->adap.timeout);
+		if (!time_left)
+			return -ETIMEDOUT;
+
+		/* Enable ACK */
+		i2c_ctl0 = rzv2m_i2c_read(priv, IICB0CTL0);
+		i2c_ctl0 |= IICB0SLAC;
+        rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+	}
+
+    *data = (u8)(data_tmp & 0x000000ff);
+
+	return 0;
+}
+
+
+/* I2c send */
+static int rzv2m_i2c_send(struct rzv2m_i2c_priv *priv, struct i2c_msg *msg,
+			int *count)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < msg->len; i++) {
+		ret = rzv2m_i2c_write_with_ACK(priv, msg->buf[i]);
+		if (ret < 0)
+			break;
+	}
+	/* Save count */
+	*count = i;
+
+	return ret;
+}
+
+/* I2c read */
+static int rzv2m_i2c_receive(struct rzv2m_i2c_priv *priv, struct i2c_msg *msg,
+			int *count)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < msg->len; i++) {
+		ret = rzv2m_i2c_read_with_ACK(priv, &msg->buf[i],
+					((msg->len - 1) == i));
+		if (ret < 0)
+			break;
+	}
+
+	/* Save count */
+	*count = i;
+
+	return ret;
+}
+
+/* Send slave address */
+static int rzv2m_i2c_send_address(struct rzv2m_i2c_priv *priv,
+			struct i2c_msg *msg, int read)
+{
+	u32 addr;
+	int ret;
+
+	if (msg->flags & I2C_M_TEN) {
+		/* 10-bit address
+		 *   addr_1: 5'b11110 | addr[9:8] | (R/nW)
+		 *   addr_2: addr[7:0]
+		 */
+		addr = 0xF0 | ((msg->addr >> 7) & 0x06);
+		addr |= read;
+		/* Send 1st address(extend code) */
+		ret = rzv2m_i2c_write_with_ACK(priv, addr);
+		if (ret < 0)
+			return ret;
+		/* Send 2nd address */
+		ret = rzv2m_i2c_write_with_ACK(priv, msg->addr & 0xFF);
+		if (ret < 0)
+			return ret;
+	} else {
+		/* 7-bit address */
+		addr = (msg->addr << 1) | read;
+		ret = rzv2m_i2c_write_with_ACK(priv, addr);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void rzv2m_i2c_stop_condition(struct rzv2m_i2c_priv *priv)
+{
+	unsigned long timeout, current_time;
+
+	timeout = jiffies + msecs_to_jiffies(priv->adap.timeout);
+
+	/* Send stop condition */
+    rzv2m_i2c_write(priv, IICB0SPT, IICB0TRG);
+	do {
+		current_time = jiffies;
+		if ((rzv2m_i2c_read(priv, IICB0STR0) & IICB0SSSP) == IICB0SSSP)
+			break;
+	} while (time_before(current_time, timeout));
+
+}
+
+/* I2c main transfer */
+static int __rzv2m_i2c_master_xfer(struct rzv2m_i2c_priv *priv,
+			struct i2c_msg *msg, int stop)
+{
+	int count = 0;
+	int ret, read = !!(msg->flags & I2C_M_RD);
+
+	/* Send start condition */
+    rzv2m_i2c_write(priv, IICB0STT, IICB0TRG);
+
+	/* Send slave address and R/W type */
+	ret = rzv2m_i2c_send_address(priv, msg, read);
+	if (ret == -ENXIO)
+		goto out;
+	else if (ret < 0)
+		goto out_reset;
+
+	if (read) {
+		ret = rzv2m_i2c_receive(priv, msg, &count);
+		if (ret < 0)
+			goto out_reset;
+	} else {
+		/* Write data */
+		ret = rzv2m_i2c_send(priv, msg, &count);
+		if (ret == -ENXIO)
+			goto out;
+		else if (ret < 0)
+			goto out_reset;
+	}
+
+	if (stop)
+		/* Send stop condition */
+		rzv2m_i2c_stop_condition(priv);
+
+	return count;
+
+out_reset:
+	rzv2m_i2c_init(priv);
+	return ret;
+out:
+	rzv2m_i2c_stop_condition(priv);
+	return ret;
+}
+
+/* I2c transfer */
+static int rzv2m_i2c_master_xfer(struct i2c_adapter *adap,
+			struct i2c_msg *msgs, int num)
+{
+	struct rzv2m_i2c_priv *priv = i2c_get_adapdata(adap);
+	int ret, i;
+
+	if (rzv2m_i2c_read(priv, IICB0STR0) & IICB0SSBS)
+		return -EAGAIN;
+
+	/* I2C main transfer  */
+	for (i = 0; i < num; i++) {
+		ret = __rzv2m_i2c_master_xfer(priv, &msgs[i],
+					(i == (num - 1)));
+		if (ret < 0)
+			return ret;
+	}
+
+	return num;
+}
+
+/* Return i2c function which is susported by RZ/V2M */
+static u32 rzv2m_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) | I2C_FUNC_10BIT_ADDR;
+}
+
+static const struct i2c_adapter_quirks rzv2m_i2c_quirks = {
+        .flags = I2C_AQ_NO_ZERO_LEN,
+};
+
+/* I2c algorithm struct */
+static struct i2c_algorithm rzv2m_i2c_algo = {
+	.master_xfer = rzv2m_i2c_master_xfer,
+	.functionality = rzv2m_i2c_func,
+};
+
+
+/* I2c driver probe */
+static int rzv2m_i2c_probe(struct platform_device *pdev)
+{
+	struct rzv2m_i2c_priv *priv;
+	struct i2c_adapter *adap;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	int irq_tia, ret;
+
+	priv = devm_kzalloc(dev, sizeof(struct rzv2m_i2c_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->base)) {
+		dev_err(dev, "found no memory resource\n");
+		return PTR_ERR(priv->base);
+	}
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "cannot get clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	/* Adapter setting */
+	adap = &priv->adap;
+	adap->nr = pdev->id;
+	adap->algo = &rzv2m_i2c_algo;
+	adap->quirks = &rzv2m_i2c_quirks;
+	adap->class = I2C_CLASS_DEPRECATED;
+	adap->dev.parent = dev;
+	adap->dev.of_node = dev->of_node;
+	adap->owner = THIS_MODULE;
+	i2c_set_adapdata(adap, priv);
+	strlcpy(adap->name, pdev->name, sizeof(adap->name));
+	init_completion(&priv->msg_tia_done);
+
+	/* Caculate bus clock rate */
+	ret = rzv2m_i2c_clock_calculate(dev, priv);
+	if (ret < 0)
+		return ret;
+	/* I2c HW init */
+	rzv2m_i2c_init(priv);
+
+	/* Request irq */
+	irq_tia = platform_get_irq(pdev, 0);
+	ret = devm_request_irq(dev, irq_tia, rzv2m_i2c_tia_irq_handler, 0,
+						dev_name(dev), priv);
+	if (ret < 0) {
+		dev_err(dev, "Unable to request irq %d\n", irq_tia);
+		return ret;
+	}
+
+	/* Save point of priv to driver data of platform*/
+	platform_set_drvdata(pdev, priv);
+
+	/* Request adapter */
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret < 0) {
+		dev_err(dev, "reg adap failed: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "probed\n");
+
+	return 0;
+}
+
+/* I2c driver remove */
+static int rzv2m_i2c_remove(struct platform_device *pdev)
+{
+	struct rzv2m_i2c_priv *priv = platform_get_drvdata(pdev);
+	u32 i2c_ctl0;
+
+	/* Delete adapter */
+	i2c_del_adapter(&priv->adap);
+
+	/* I2c disable */
+	i2c_ctl0 = rzv2m_i2c_read(priv, IICB0CTL0);
+	i2c_ctl0 &= ~IICB0IICE;
+    rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+/* I2c suspend */
+static int rzv2m_i2c_suspend(struct device *dev)
+{
+	struct rzv2m_i2c_priv *priv = dev_get_drvdata(dev);
+	u32 i2c_ctl0;
+
+	/* I2c disable */
+	i2c_ctl0 = rzv2m_i2c_read(priv, IICB0CTL0);
+	i2c_ctl0 &= ~IICB0IICE;
+    rzv2m_i2c_write(priv, i2c_ctl0, IICB0CTL0);
+
+	return 0;
+}
+
+/* I2c resume */
+static int rzv2m_i2c_resume(struct device *dev)
+{
+	int ret;
+	struct rzv2m_i2c_priv *priv = dev_get_drvdata(dev);
+
+	/* Caculate bus clock rate */
+	ret = rzv2m_i2c_clock_calculate(dev, priv);
+	if (ret < 0)
+		return ret;
+	/* I2c init */
+	rzv2m_i2c_init(priv);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(rzv2m_i2c_pm, rzv2m_i2c_suspend,
+			 rzv2m_i2c_resume);
+
+static const struct of_device_id rzv2m_i2c_ids[] = {
+	{ .compatible = "renesas,rzv2m-i2c", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rzv2m_i2c_ids);
+
+static struct platform_driver rzv2m_i2c_driver = {
+	.driver	= {
+		.name	= "rzv2m-i2c",
+		.pm = &rzv2m_i2c_pm,
+		.of_match_table = rzv2m_i2c_ids,
+	},
+	.probe		= rzv2m_i2c_probe,
+	.remove		= rzv2m_i2c_remove,
+};
+module_platform_driver(rzv2m_i2c_driver);
+
+MODULE_DESCRIPTION("RZ/V2M I2C bus driver");
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c
index d9668f8..b414d36 100644
--- a/drivers/usb/gadget/udc/renesas_usb3.c
+++ b/drivers/usb/gadget/udc/renesas_usb3.c
@@ -38,7 +38,7 @@
 #define USB3_USB20_CON		0x204
 #define USB3_USB30_CON		0x208
 #define USB3_USB_STA		0x210
-#define USB3_DRD_CON		0x218
+#define USB3_DRD_CON            0x400
 #define USB3_USB_INT_STA_1	0x220
 #define USB3_USB_INT_STA_2	0x224
 #define USB3_USB_INT_ENA_1	0x228
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 1a4ea98..8ddadc7 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -94,6 +94,15 @@ config USB_XHCI_TEGRA
 	  Say 'Y' to enable the support for the xHCI host controller
 	  found in NVIDIA Tegra124 and later SoCs.
 
+config USB_XHCI_RZV2M
+       tristate "xHCI support for RZ/V2M"
+       select USB_XHCI_PLATFORM
+       depends on ARCH_RENESAS || COMPILE_TEST
+       ---help---
+         Say 'Y' to enable the support for the xHCI host controller
+         found in RZ/V2M.
+
+
 endif # USB_XHCI_HCD
 
 config USB_EHCI_HCD
@@ -798,3 +807,18 @@ config USB_HCD_TEST_MODE
 	  This option is of interest only to developers who need to validate
 	  their USB hardware designs.  It is not needed for normal use.  If
 	  unsure, say N.
+
+config USB_OHCI_RZV2M
+       select GENERIC_PHY
+       select USB_OHCI_HCD_PLATFORM
+       tristate "RZ/V2M USB2.0 OHCI Host driver"
+       ---help---
+         Enable support of the on-chip OHCI controller on RZ/V2M chip.
+
+config USB_EHCI_RZV2M
+       select GENERIC_PHY
+       select USB_EHCI_HCD_PLATFORM
+       tristate "RZ/V2M USB2.0 EHCI Host driver"
+       ---help---
+         Enable support of the on-chip EHCI controller on RZ/V2M chip.
+
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index e623526..156ead7 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -31,6 +31,10 @@ ifneq ($(CONFIG_USB_XHCI_RCAR), )
 	xhci-plat-hcd-y		+= xhci-rcar.o
 endif
 
+ifneq ($(CONFIG_USB_XHCI_RZV2M), )
+       xhci-plat-hcd-y         += xhci-rzv2m.o
+endif
+
 ifneq ($(CONFIG_DEBUG_FS),)
 	xhci-hcd-y		+= xhci-debugfs.o
 endif
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index adc437c..41cbb3c 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -23,6 +23,7 @@
 #include "xhci-plat.h"
 #include "xhci-mvebu.h"
 #include "xhci-rcar.h"
+#include "xhci-rzv2m.h"
 
 static struct hc_driver __read_mostly xhci_plat_hc_driver;
 
@@ -111,6 +112,14 @@ static const struct xhci_plat_priv xhci_plat_renesas_rcar_gen3 = {
 	.resume_quirk = xhci_rcar_resume_quirk,
 };
 
+static const struct xhci_plat_priv xhci_plat_renesas_rzv2m = {
+//    .firmware_name = XHCI_RCAR_FIRMWARE_NAME_V3,
+    .init_quirk = xhci_rzv2m_drd_init,
+    .plat_start = xhci_rzv2m_start,
+//    .resume_quirk = xhci_rcar_resume_quirk,
+};
+
+
 static const struct of_device_id usb_xhci_of_match[] = {
 	{
 		.compatible = "generic-xhci",
@@ -141,8 +150,8 @@ static const struct of_device_id usb_xhci_of_match[] = {
 		.compatible = "renesas,rcar-gen2-xhci",
 		.data = &xhci_plat_renesas_rcar_gen2,
 	}, {
-		.compatible = "renesas,rcar-gen3-xhci",
-		.data = &xhci_plat_renesas_rcar_gen3,
+                .compatible = "renesas,rzv2m-xhci",
+                .data = &xhci_plat_renesas_rzv2m,
 	},
 	{},
 };
diff --git a/drivers/usb/host/xhci-rzv2m.c b/drivers/usb/host/xhci-rzv2m.c
new file mode 100755
index 0000000..4f42633
--- /dev/null
+++ b/drivers/usb/host/xhci-rzv2m.c
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * xHCI host controller driver for RZV2M
+ *
+ * Copyright (C) 2019 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include "xhci.h"
+
+/**** USB IP base address ***/
+#define RZV2M_USBTEST_BASE	0xA3F90000
+#define RZV2M_USBPERI_BASE	0x85070000
+#define RZV2M_USBHOST_BASE	0x85060000
+
+/*** Register Offset ***/
+#define RZV2M_USB3_INTEN	0x1044	/* Interrupt Enable */
+
+/*** Register Settings ***/
+/* Interrupt Enable */
+#define RZV2M_USB3_INT_XHC_ENA	0x00000001
+#define RZV2M_USB3_INT_HSE_ENA	0x00000004
+#define RZV2M_USB3_INT_ENA_VAL	(RZV2M_USB3_INT_XHC_ENA \
+				 | RZV2M_USB3_INT_HSE_ENA)
+
+/*** USB TEST Register Offset ***/
+#define RZV2M_USBTEST_HC_OFFSET	(RZV2M_USBTEST_BASE-RZV2M_USBHOST_BASE) /* USBTEST Offset */
+#define RZV2M_USBTEST_RST1	0x000	/* Reset Register 1 */
+#define RZV2M_USBTEST_RST2	0x004	/* Reset Register 2 */
+#define RZV2M_USBTEST_CLKRST	0x308	/* Clock Reset Register */
+
+/*** USB TEST Register Settings ***/
+#define RZV2M_USBTEST_SSC_EN		0x00001000
+
+#define RZV2M_USBTEST_PIPE0_RST	0x00000001
+#define RZV2M_USBTEST_PORT_RST0	0x00000002
+#define RZV2M_USBTEST_PHY_RST	0x00000004
+#define RZV2M_USBTEST_PIPE0_ODEN	0x00000010
+#define RZV2M_USBTEST_PORT_ODEN	0x00000020
+
+#define RZV2M_USBTEST_REF_SSP_EN	0x00000001
+
+/*** DRD Register Offset ***/
+#define RZV2M_DRD_BASE_OFFSET	(RZV2M_USBPERI_BASE - RZV2M_USBHOST_BASE)
+#define RZV2M_DRD_HC_OFFSET	(0x400+RZV2M_DRD_BASE_OFFSET)	 /* DRD Offset */
+#define RZV2M_DRD_DRDCON		(0x000)   /* DRDCON */
+
+/*** USB TEST Register Settings ***/
+#define RZV2M_DRD_PERI_RST	0x80000000 /* Pericon Rst */
+#define RZV2M_DRD_HOST_RST	0x40000000 /* Hostcon Rst */
+#define RZV2M_DRD_PERICON	0x01000000 /* PeriHost select*/
+
+#define RZV2M_DRD_REG 0x85070400
+
+int xhci_rzv2m_drd_init(struct usb_hcd *hcd)
+{
+
+	u32 temp;
+	void __iomem * remap_addr;
+	
+	remap_addr = ioremap(RZV2M_DRD_REG, sizeof(*remap_addr));
+	if (!remap_addr) {
+        return -EINVAL;
+    }
+
+	temp = readl( remap_addr );
+
+	iounmap( remap_addr );
+	
+	if(temp == (RZV2M_DRD_HOST_RST | RZV2M_DRD_PERICON) )
+		return -EFAULT;
+	else
+	  //no nothing
+	
+	return 0;
+}
+
+void xhci_rzv2m_usbtest_init(struct usb_hcd *hcd)
+{
+	/* USB TEST INIT */
+	u32 temp;
+
+	if (hcd->regs != NULL) {
+
+		/* ref_ssp_en set */
+		temp = readl(hcd->regs +
+				RZV2M_USBTEST_HC_OFFSET + RZV2M_USBTEST_RST2);
+		temp |= RZV2M_USBTEST_REF_SSP_EN;
+		writel(temp, hcd->regs +
+				RZV2M_USBTEST_HC_OFFSET + RZV2M_USBTEST_RST2);
+
+		udelay(10);
+
+		/* USB/PHY reset state release */
+		temp = readl(hcd->regs +
+				RZV2M_USBTEST_HC_OFFSET + RZV2M_USBTEST_RST1);
+		temp &= ~(RZV2M_USBTEST_PIPE0_RST |
+				RZV2M_USBTEST_PORT_RST0 |
+				RZV2M_USBTEST_PHY_RST);
+		writel(temp, hcd->regs +
+				RZV2M_USBTEST_HC_OFFSET + RZV2M_USBTEST_RST1);
+
+		temp = readl(hcd->regs +
+				RZV2M_USBTEST_HC_OFFSET + RZV2M_USBTEST_RST1);
+		temp &= ~(RZV2M_USBTEST_PIPE0_ODEN |
+				RZV2M_USBTEST_PORT_ODEN);
+		writel(temp, hcd->regs +
+				RZV2M_USBTEST_HC_OFFSET + RZV2M_USBTEST_RST1);
+		udelay(75);
+	}
+}
+
+void xhci_rzv2m_start(struct usb_hcd *hcd)
+{
+	u32 temp;
+	if (hcd->regs != NULL) {
+		/* Interrupt Enable */
+		temp = readl(hcd->regs + RZV2M_USB3_INTEN);
+		temp |= RZV2M_USB3_INT_ENA_VAL;
+		writel(temp, hcd->regs + RZV2M_USB3_INTEN);
+	}
+	else{
+		return -EFAULT;
+	}
+	
+	return 0;
+}
+
diff --git a/drivers/usb/host/xhci-rzv2m.h b/drivers/usb/host/xhci-rzv2m.h
new file mode 100755
index 0000000..2bc2792
--- /dev/null
+++ b/drivers/usb/host/xhci-rzv2m.h
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * drivers/usb/host/xhci-rzv2m.h
+ *
+ * Copyright (C) 2019 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#ifndef _XHCI_RZV2M_H
+#define _XHCI_RZV2M_H
+
+#if IS_ENABLED(CONFIG_USB_XHCI_RZV2M)
+void xhci_rzv2m_start(struct usb_hcd *hcd);
+void xhci_rzv2m_usbtest_init(struct usb_hcd *hcd);
+int xhci_rzv2m_drd_init(struct usb_hcd *hcd);
+#else
+static inline void xhci_rzv2m_start(struct usb_hcd *hcd)
+{
+}
+static inline void xhci_rzv2m_usbtest_init(struct usb_hcd *hcd)
+{
+}
+static inline void xhci_rzv2m_drd_init(struct usb_hcd *hcd)
+{
+}
+#endif
+#endif /* _XHCI_RZV2M_H */
-- 
2.7.4

