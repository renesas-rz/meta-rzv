From ab9737628f424fe4094a9651901674241aa3531e Mon Sep 17 00:00:00 2001
From: Canh Dao <canh.dao.ct@renesas.com>
Date: Tue, 14 Sep 2021 11:10:38 +0700
Subject: [PATCH] added-cpg_drv

Signed-off-by: Canh Dao <canh.dao.ct@renesas.com>
---
 arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi |  13 +-
 drivers/clk/renesas/Kconfig                   |   5 +-
 drivers/clk/renesas/Makefile                  |   3 +-
 drivers/clk/renesas/r9a09g011-cpg-mssr.h      | 702 +++++++++++++++++++++++
 drivers/clk/renesas/r9a09g011gbg-cpg-mssr.c   | 432 +++++++-------
 drivers/clk/renesas/renesas-cpg-clkon.c       | 795 ++++++++++++++++++++++++++
 drivers/clk/renesas/renesas-cpg-clkon.h       | 194 +++++++
 include/linux/clk/renesas.h                   |  10 +-
 8 files changed, 1928 insertions(+), 226 deletions(-)
 create mode 100755 drivers/clk/renesas/r9a09g011-cpg-mssr.h
 create mode 100644 drivers/clk/renesas/renesas-cpg-clkon.c
 create mode 100644 drivers/clk/renesas/renesas-cpg-clkon.h

diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
index 06d8ab1..dc71d5c 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
@@ -134,7 +134,7 @@
 
         cpg: clock-controller@A3500000 {
             compatible = "renesas,r8arzv2m-cpg-mssr";
-            reg = <0 0xA3500000 0 0x4>;
+            reg = <0 0xA3500000 0 0x1000>;
             clocks = <&extal_clk>;
             clock-names = "extal";
             #clock-cells = <2>;
@@ -154,7 +154,9 @@
             compatible = "renesas,rzv2m-i2c";
             reg = <0 0xa4030000 0 0x80>;
             interrupts = <GIC_SPI 232 IRQ_TYPE_EDGE_RISING>,<GIC_SPI 236 IRQ_TYPE_EDGE_RISING>;
-            clocks = <&pclk>;
+            /*clocks = <&pclk>;*/
+            clocks = <&cpg CPG_MOD 912>;
+            reset = <&cpg 912>;
             i2c-scl-internal-delay-ns = <110>;
             status = "disabled";
         };
@@ -165,7 +167,7 @@
             compatible = "renesas,rzv2m-i2c";
             reg = <0 0xa4030080 0 0x80>;
             interrupts = <GIC_SPI 233 IRQ_TYPE_EDGE_RISING>,<GIC_SPI 237 IRQ_TYPE_EDGE_RISING>;
-            clocks = <&pclk>;
+            clocks = <&cpg CPG_MOD 1012>;
             i2c-scl-internal-delay-ns = <110>;
             status = "disabled";
         };
@@ -252,7 +254,6 @@
                   <0x0 0x82060000 0 0x20000>;
             interrupts = <GIC_PPI 9
                     (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_HIGH)>;
-            clocks = <&cpg CPG_MOD 408>;
             clock-names = "clk";
             power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;
             resets = <&cpg 408>;
@@ -336,8 +337,10 @@
             compatible =  "renesas,tim-rzv2m";
             reg = <0 0xa4000000 0 0x80>;
             interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
-            clocks = <&timclk>;
             clock-names = "timclk";
+            reset = <&cpg 904>;
+            reset-names = "tim0";
+
             status = "disabled";
         };
 
diff --git a/drivers/clk/renesas/Kconfig b/drivers/clk/renesas/Kconfig
index 0c2a1e2..b9168d7 100644
--- a/drivers/clk/renesas/Kconfig
+++ b/drivers/clk/renesas/Kconfig
@@ -95,7 +95,7 @@ config CLK_R8A774E1
 
 config CLK_R9A09G011GBG
        bool "RZ/V2M clock support" if COMPILE_TEST
-       select CLK_RCAR_GEN3_CPG
+       select CLK_RENESAS_CPG_CLKON
 
 config CLK_R8A7778
 	bool "R-Car M1A clock support" if COMPILE_TEST
@@ -198,4 +198,7 @@ config CLK_RENESAS_CPG_MSTP
 config CLK_RENESAS_DIV6
 	bool "DIV6 clock support" if COMPILE_TEST
 
+config CLK_RENESAS_CPG_CLKON
+       bool "CPG/CLK_ON clock support" if COMPILE_TEST
+
 endif # CLK_RENESAS
diff --git a/drivers/clk/renesas/Makefile b/drivers/clk/renesas/Makefile
index 1fee36c..3586561 100644
--- a/drivers/clk/renesas/Makefile
+++ b/drivers/clk/renesas/Makefile
@@ -12,7 +12,7 @@ obj-$(CONFIG_CLK_R8A774A3)		+= r8a774a1-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A774B1)		+= r8a774b1-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A774C0)		+= r8a774c0-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A774E1)		+= r8a774e1-cpg-mssr.o
-obj-$(CONFIG_CLK_R9A09G011GBG)          += r9a09g011gbg-cpg-mssr.o
+obj-$(CONFIG_CLK_R9A09G011GBG) += r9a09g011gbg-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A7778)		+= clk-r8a7778.o
 obj-$(CONFIG_CLK_R8A7779)		+= clk-r8a7779.o
 obj-$(CONFIG_CLK_R8A7790)		+= r8a7790-cpg-mssr.o
@@ -39,3 +39,4 @@ obj-$(CONFIG_CLK_RCAR_USB2_CLOCK_SEL)	+= rcar-usb2-clock-sel.o
 obj-$(CONFIG_CLK_RENESAS_CPG_MSSR)	+= renesas-cpg-mssr.o
 obj-$(CONFIG_CLK_RENESAS_CPG_MSTP)	+= clk-mstp.o
 obj-$(CONFIG_CLK_RENESAS_DIV6)		+= clk-div6.o
+obj-$(CONFIG_CLK_RENESAS_CPG_CLKON) += renesas-cpg-clkon.o
diff --git a/drivers/clk/renesas/r9a09g011-cpg-mssr.h b/drivers/clk/renesas/r9a09g011-cpg-mssr.h
new file mode 100755
index 0000000..95c15ca
--- /dev/null
+++ b/drivers/clk/renesas/r9a09g011-cpg-mssr.h
@@ -0,0 +1,702 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Renesas Electronics Corp.
+ */
+#ifndef __R8ARZV2M_CPG_MSSR_H__
+#define __R8ARZV2M_CPG_MSSR_H__
+
+
+/*******************************************************************************
+ * DISCLAIMER
+ * This software is supplied by Renesas Electronics Corporation and is only
+ * intended for use with Renesas products. No other uses are authorized. This
+ * software is owned by Renesas Electronics Corporation and is protected under
+ * all applicable laws, including copyright laws.
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+ * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
+ * LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
+ * AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
+ * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
+ * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
+ * ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
+ * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ * Renesas reserves the right, without notice, to make changes to this software
+ * and to discontinue the availability of this software. By using this software,
+ * you agree to the additional terms and conditions found by accessing the
+ * following link:
+ * http://www.renesas.com/disclaimer
+ * Copyright (C) 2019 Renesas Electronics Corporation. All rights reserved.
+ ******************************************************************************/
+/*******************************************************************************
+ * File Name    : rdk_cmn_cpg.h
+ * Version      : 0.9
+ * Description  : This module solves all the world's problems
+ ******************************************************************************/
+
+#ifndef RDK_CMN_CPG_H
+#define RDK_CMN_CPG_H
+
+/* CPG */
+#define CPG_BASE_ADDRESS        (0x0A3500000ULL)
+
+/** Registor Offset */
+#define CPG_PLL1_STBY           (0x0000)
+#define CPG_PLL1_CLK1           (0x0004)
+#define CPG_PLL1_CLK2           (0x0008)
+#define CPG_PLL1_MON            (0x000C)
+#define CPG_PLL2_STBY           (0x0010)
+#define CPG_PLL2_CLK1           (0x0014)
+#define CPG_PLL2_CLK2           (0x0018)
+#define CPG_PLL2_MON            (0x001C)
+#define CPG_PLL3_STBY           (0x0020)
+#define CPG_PLL3_CLK1           (0x0024)
+#define CPG_PLL3_CLK2           (0x0028)
+#define CPG_PLL3_MON            (0x002C)
+#define CPG_PLL6_STBY           (0x0030)
+#define CPG_PLL6_CLK1           (0x0034)
+#define CPG_PLL6_CLK2           (0x0038)
+#define CPG_PLL6_MON            (0x003C)
+#define CPG_PLL7_STBY           (0x0040)
+#define CPG_PLL7_CLK1           (0x0044)
+#define CPG_PLL7_CLK2           (0x0048)
+#define CPG_PLL7_MON            (0x004C)
+
+
+#define CPG_PLL4_STBY           (0x0100)
+#define CPG_PLL4_CLK1           (0x0104)
+#define CPG_PLL4_CLK2           (0x0108)
+#define CPG_PLL4_MON            (0x010C)
+
+
+#define CPG_PLL1_CCTRL_RST      (0x0180)
+#define CPG_PLL2_CCTRL_RST      (0x0184)
+#define CPG_PLL3_CCTRL_RST      (0x0188)
+#define CPG_PLL4_CCTRL_RST      (0x018C)
+
+#define CPG_PLL7_CCTRL_RST      (0x0198)
+
+#define CPG_CA53_DDIV           (0x0200)
+#define CPG_SYS_DDIV            (0x0204)
+#define CPG_CR8REF_DDIV         (0x0208)
+#define CPG_NFI_DDIV            (0x020C)
+#define CPG_MMCDDI_DDIV         (0x0210)
+#define CPG_CLK48_DSEL          (0x0214)
+#define CPG_ISP_DDIV1           (0x0218)
+#define CPG_ISP_DDIV2           (0x021C)
+#define CPG_ISP_DSEL            (0x0220)
+#define CPG_CLKSTATUS           (0x0224)
+
+
+#define CPG_SDIEMM_SSEL         (0x0300)
+#define CPG_STG_SDIV            (0x0304)
+#define CPG_STGCIF_SSEL         (0x0308)
+#define CPG_DISP_SDIV1          (0x030C)
+#define CPG_DISP_SDIV2          (0x0310)
+#define CPG_DISP_SSEL1          (0x0314)
+#define CPG_DISP_SSEL2          (0x0318)
+#define CPG_GMCLK_SDIV          (0x031C)
+#define CPG_GMCLK_SSEL          (0x0320)
+#define CPG_MTR_SSEL            (0x0324)
+#define CPG_URT_RCLK_SDIV       (0x0328)
+#define CPG_URT_RCLK_SSEL       (0x032C)
+#define CPG_CSI_RCLK_SSEL       (0x0330)
+
+
+#define CPG_CLK_ON1             (0x0400)
+#define CPG_CLK_ON2             (0x0404)
+#define CPG_CLK_ON3             (0x0408)
+#define CPG_CLK_ON4             (0x040C)
+#define CPG_CLK_ON5             (0x0410)
+#define CPG_CLK_ON6             (0x0414)
+#define CPG_CLK_ON7             (0x0418)
+#define CPG_CLK_ON8             (0x041C)
+#define CPG_CLK_ON9             (0x0420)
+#define CPG_CLK_ON10            (0x0424)
+#define CPG_CLK_ON11            (0x0428)
+#define CPG_CLK_ON12            (0x042C)
+#define CPG_CLK_ON13            (0x0430)
+#define CPG_CLK_ON14            (0x0434)
+#define CPG_CLK_ON15            (0x0438)
+#define CPG_CLK_ON16            (0x043C)
+#define CPG_CLK_ON17            (0x0440)
+#define CPG_CLK_ON18            (0x0444)
+#define CPG_CLK_ON19            (0x0448)
+#define CPG_CLK_ON20            (0x044C)
+#define CPG_CLK_ON21            (0x0450)
+#define CPG_CLK_ON22            (0x0454)
+#define CPG_CLK_ON23            (0x0458)
+#define CPG_CLK_ON24            (0x045C)
+#define CPG_CLK_ON25            (0x0460)
+#define CPG_CLK_ON26            (0x0464)
+#define CPG_CLK_ON27            (0x0468)
+
+
+#define CPG_WDT_RST             (0x0500)
+#define CPG_RST_MSK             (0x0504)
+
+
+#define CPG_RST1                (0x0600)
+#define CPG_RST2                (0x0604)
+#define CPG_RST3                (0x0608)
+#define CPG_RST4                (0x060C)
+#define CPG_RST5                (0x0610)
+#define CPG_RST6                (0x0614)
+#define CPG_RST7                (0x0618)
+#define CPG_RST8                (0x061C)
+#define CPG_RST9                (0x0620)
+#define CPG_RST10               (0x0624)
+#define CPG_RST11               (0x0628)
+#define CPG_RST12               (0x062C)
+#define CPG_RST13               (0x0630)
+#define CPG_RST14               (0x0634)
+#define CPG_RST15               (0x0638)
+
+
+#define CPG_RST_MON             (0x0680)
+
+#define CPG_PD_RST              (0x0800)
+
+
+/** Bit assign */
+#define CPG_PLL_STBY_RESETB                 (0x00000001)
+#define CPG_PLL_STBY_SSC_EN                 (0x00000004)
+#define CPG_PLL_STBY_SSC_MODE_MSK           (0x00000030)
+#define CPG_PLL_STBY_SSC_MODE_DOWN_SPREAD   (0x00000000)
+#define CPG_PLL_STBY_SSC_MODE_UP_SPREAD     (0x00000010)
+#define CPG_PLL_STBY_SSC_MODE_CENTER_SPREAD (0x00000020)
+#define CPG_PLL_STBY_WEN_RESETB             (0x00010000)
+#define CPG_PLL_STBY_WEN_SSE_EN             (0x00040000)
+#define CPG_PLL_STBY_WEN_SSC_MODE           (0x00100000)
+
+#define CPG_PLL_CLK1_DIV_P_MSK              (0x0000001F)
+#define CPG_PLL_CLK1_DIV_M_MSK              (0x000003FF)
+#define CPG_PLL_CLK1_DIV_K_MSK              (0x0000FFFF)
+
+#define CPG_PLL_CLK1_DIV_P_SHIFT            (0)
+#define CPG_PLL_CLK1_DIV_M_SHIFT            (5)
+#define CPG_PLL_CLK1_DIV_K_SHIFT            (16)
+
+#define CPG_PLL_CLK1_DIV_P_MAX              (+32767)
+#define CPG_PLL_CLK1_DIV_P_MIN              (-32768)
+
+#define CPG_PLL_CLK1_DIV_M_MAX              (533)
+#define CPG_PLL_CLK1_DIV_M_MIN              (64)
+
+#define CPG_PLL_CLK1_DIV_K_MAX              (8)
+#define CPG_PLL_CLK1_DIV_K_MIN              (2)
+
+#define CPG_PLL_CLK2_DIV_S_MSK              (0x00000007)
+#define CPG_PLL_CLK2_MRR_MSK                (0x0000003F)
+#define CPG_PLL_CLK2_MFR_MSK                (0x000000FF)
+
+#define CPG_PLL_CLK2_DIV_S_SHIFT            (0)
+#define CPG_PLL_CLK2_MRR_SHIFT              (8)
+#define CPG_PLL_CLK2_MFR_SHIFT              (6)
+
+#define CPG_PLL_CLK2_DIV_S_MAX              (6)
+#define CPG_PLL_CLK2_DIV_S_MIN              (0)
+
+#define CPG_PLL_CLK2_MRR_MAX                (63)
+#define CPG_PLL_CLK2_MRR_MIN                (1)
+
+#define CPG_PLL_CLK2_MFR_MAX                (255)
+#define CPG_PLL_CLK2_MFR_MIN                (0)
+
+#define CPG_PLL_MON_RESETB                  (0x00000001)
+#define CPG_PLL_MON_PLL_LOCK                (0x00000010)
+
+#define CPG_PLL1_CCTRL_RST_P1_0_RST         (0x00000001)        /** DIV A */
+#define CPG_PLL1_CCTRL_WEN_RST_P1_0_RST     (0x00010000)
+
+#define CPG_PLL2_CCTRL_RST_P2_0_RSTB        (0x00000001)        /** PL2_DIV */
+#define CPG_PLL2_CCTRL_RST_P2_1_RSTB        (0x00000002)        /** DIV B, D, E, DIVSEL G */
+#define CPG_PLL2_CCTRL_RST_P2_2_RSTB        (0x00000004)        /** SEL B */
+#define CPG_PLL2_CCTRL_RST_P2_3_RSTB        (0x00000008)        /** PL2_DIV DIV2 (800MHz*1/4) */
+#define CPG_PLL2_CCTRL_RST_P2_4_RSTB        (0x00000010)        /** DIV_NFI */
+#define CPG_PLL2_CCTRL_RST_P2_5_RSTB        (0x00000020)        /** PL2_DIV DIV8 (200MHz*1/2) */
+#define CPG_PLL2_CCTRL_RST_P2_6_RSTB        (0x00000040)        /** DIVSEL F */
+#define CPG_PLL2_CCTRL_RST_P2_7_RSTB        (0x00000080)        /** DIV H */
+#define CPG_PLL2_CCTRL_RST_P2_9_RSTB        (0x00000200)        /** DIV I, J, M */
+#define CPG_PLL2_CCTRL_RST_P2_10_RSTB       (0x00000400)        /** DIV M(1/2), JPEG0_CLK DIV_I, JPG1_CLK DIV_I, VCD_PCLK DIV_I */
+#define CPG_PLL2_CCTRL_RST_P2_11_RSTB       (0x00000800)        /** DIV T */
+#define CPG_PLL2_CCTRL_RST_P2_12_RSTB       (0x00001000)        /** DIV U */
+#define CPG_PLL2_CCTRL_RST_P2_13_RSTB       (0x00002000)        /** DIV H2 */
+#define CPG_PLL2_CCTRL_RST_WEN_P2_0_RSTB    (0x00010000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_1_RSTB    (0x00020000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_2_RSTB    (0x00040000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_3_RSTB    (0x00080000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_4_RSTB    (0x00100000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_5_RSTB    (0x00200000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_6_RSTB    (0x00400000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_7_RSTB    (0x00800000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_9_RSTB    (0x02000000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_10_RSTB   (0x04000000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_11_RSTB   (0x08000000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_12_RSTB   (0x10000000)
+#define CPG_PLL2_CCTRL_RST_WEN_P2_13_RSTB   (0x20000000)
+
+#define CPG_PLL3_CCTRL_RST_P3_0_RSTB        (0x00000001)        /** DIV X */
+#define CPG_PLL3_CCTRL_RST_P3_1_RSTB        (0x00000002)        /** DIV X 1/2 */
+#define CPG_PLL3_CCTRL_RST_WEN_P3_0_RSTB    (0x00010000)
+#define CPG_PLL3_CCTRL_RST_WEN_P3_1_RSTB    (0x00020000)
+
+#define CPG_PLL4_CCTRL_RST_P4_0_RSTB        (0x00000001)        /** DIV STG */
+#define CPG_PLL4_CCTRL_RST_P4_1_RSTB        (0x00000002)        /** DIV_STG 1/2 */
+#define CPG_PLL4_CCTRL_RST_P4_2_RSTB        (0x00000004)        /** DIV STG 1/2 -> 1/2 */
+#define CPG_PLL4_CCTRL_RST_P4_3_RSTB        (0x00000008)        /** PLL4 1/3 */
+#define CPG_PLL4_CCTRL_RST_P4_4_RSTB        (0x00000010)        /** PLL4 1/3 -> 1/2 */
+#define CPG_PLL4_CCTRL_RST_P4_5_RSTB        (0x00000020)        /** DIV W */
+#define CPG_PLL4_CCTRL_RST_WEN_P4_0_RSTB    (0x00010000)
+#define CPG_PLL4_CCTRL_RST_WEN_P4_1_RSTB    (0x00020000)
+#define CPG_PLL4_CCTRL_RST_WEN_P4_2_RSTB    (0x00040000)
+#define CPG_PLL4_CCTRL_RST_WEN_P4_3_RSTB    (0x00080000)
+#define CPG_PLL4_CCTRL_RST_WEN_P4_4_RSTB    (0x00100000)
+#define CPG_PLL4_CCTRL_RST_WEN_P4_5_RSTB    (0x00200000)
+
+#define CPG_PLL7_CCTRL_RST_P7_0_RSTB        (0x00000001)        /** DIV R */
+#define CPG_PLL7_CCTRL_RST_P7_1_RSTB        (0x00000002)        /** DIV R 1/2 */
+#define CPG_PLL7_CCTRL_RST_P7_2_RSTB        (0x00000004)        /** DIV LCILP */
+#define CPG_PLL7_CCTRL_RST_WEN_P7_0_RSTB    (0x00010000)
+#define CPG_PLL7_CCTRL_RST_WEN_P7_1_RSTB    (0x00020000)
+#define CPG_PLL7_CCTRL_RST_WEN_P7_2_RSTB    (0x00040000)
+
+#define CPG_CA53_DDIV_DIVA_SET_MSK          (0x00000007)
+#define CPG_CA53_DDIV_DIVA_SET_SHIFT        (0)
+#define CPG_CA53_DDIV_DIVA_SET_MAX          (6)
+#define CPG_CA53_DDIV_DIVA_SET_MIN          (0)
+#define CPG_CA53_DDIV_WEN_DIVA              (0x00010000)
+
+#define CPG_SYS_DDIV_DIVB_SET_MSK           (0x00000003)
+#define CPG_SYS_DDIV_DIVB_SET_SHIFT         (0)
+#define CPG_SYS_DDIV_DIVB_SET_MAX           (3)
+#define CPG_SYS_DDIV_DIVB_SET_MIN           (0)
+#define CPG_SYS_DDIV_DIVD_SET_MSK           (0x00000003)
+#define CPG_SYS_DDIV_DIVD_SET_SHIFT         (4)
+#define CPG_SYS_DDIV_DIVD_SET_MAX           (2)
+#define CPG_SYS_DDIV_DIVD_SET_MIN           (0)
+#define CPG_SYS_DDIV_DIVE_SET_MSK           (0x00000001)
+#define CPG_SYS_DDIV_DIVE_SET_SHIFT         (8)
+#define CPG_SYS_DDIV_DIVE_SET_MAX           (1)
+#define CPG_SYS_DDIV_DIVE_SET_MIN           (0)
+#define CPG_SYS_DDIV_WEN_DIVB               (0x00010000)
+#define CPG_SYS_DDIV_WEN_DIVD               (0x00100000)
+#define CPG_SYS_DDIV_WEN_DIVE               (0x01000000)
+
+#define CPG_CR8REF_DDIV_DIVF_SET_MSK        (0x00000007)
+#define CPG_CR8REF_DDIV_DIVF_SET_SHIFT      (0)
+#define CPG_CR8REF_DDIV_DIVF_SET_MAX        (4)
+#define CPG_CR8REF_DDIV_DIVF_SET_MIN        (0)
+#define CPG_CR8REF_DDIV_DIVG_SET_MSK        (0x00000003)
+#define CPG_CR8REF_DDIV_DIVG_SET_SHIFT      (4)
+#define CPG_CR8REF_DDIV_DIVG_SET_MAX        (3)
+#define CPG_CR8REF_DDIV_DIVG_SET_MIN        (0)
+#define CPG_CR8REF_DDIV_WEN_DIVF            (0x00010000)
+#define CPG_CR8REF_DDIV_WEN_DIVG            (0x00100000)
+
+#define CPG_NFI_DDIV_DIVNFI_SET_MSK         (0x00000003)
+#define CPG_NFI_DDIV_DIVNFI_SET_SHIFT       (0)
+#define CPG_NFI_DDIV_DIVNFI_SET_MAX         (3)
+#define CPG_NFI_DDIV_DIVNFI_SET_MIN         (0)
+#define CPG_NFI_DDIV_WEN_DIVNFI             (0x00010000)
+
+#define CPG_MMCDDI_DDIV_DIVX_SET_MSK        (0x00000003)
+#define CPG_MMCDDI_DDIV_DIVX_SET_SHIFT      (0)
+#define CPG_MMCDDI_DDIV_DIVX_SET_MAX        (2)
+#define CPG_MMCDDI_DDIV_DIVX_SET_MIN        (0)
+#define CPG_MMCDDI_DDIV_WEN_DIVX            (0x00010000)
+
+#define CPG_CLK48_DSEL_SELB                 (0x00000001)        /** ICB - DIV B */
+#define CPG_CLK48_DSEL_SELD                 (0x00000002)        /** PCLK_200 - DIV D */
+#define CPG_CLK48_DSEL_SELE                 (0x00000004)        /** PCLK_100 - DIV E */
+#define CPG_CLK48_DSEL_SELF                 (0x00000008)        /** CR8 core - DIVSEL F */
+#define CPG_CLK48_DSEL_SELG                 (0x00000010)        /** Reflex - DIVSEL G */
+#define CPG_CLK48_DSEL_SELNFI               (0x00000020)        /** NFI - DIV NFI */
+#define CPG_CLK48_DSEL_WEN_SELB             (0x00010000)
+#define CPG_CLK48_DSEL_WEN_SELD             (0x00020000)
+#define CPG_CLK48_DSEL_WEN_SELE             (0x00040000)
+#define CPG_CLK48_DSEL_WEN_SELF             (0x00080000)
+#define CPG_CLK48_DSEL_WEN_SELG             (0x00100000)
+#define CPG_CLK48_DSEL_WEN_SELNFI           (0x00200000)
+
+#define CPG_ISP_DDIV1_DIVH_SET_MSK          (0x00000003)
+#define CPG_ISP_DDIV1_DIVH_SET_SHIFT        (0)
+#define CPG_ISP_DDIV1_DIVH_SET_MAX          (3)
+#define CPG_ISP_DDIV1_DIVH_SET_MIN          (0)
+#define CPG_ISP_DDIV1_DIVH2_SET_MSK         (0x00000003)
+#define CPG_ISP_DDIV1_DIVH2_SET_SHIFT       (4)
+#define CPG_ISP_DDIV1_DIVH2_SET_MAX         (3)
+#define CPG_ISP_DDIV1_DIVH2_SET_MIN         (0)
+#define CPG_ISP_DDIV1_WEN_DIVH              (0x00010000)
+#define CPG_ISP_DDIV1_WEN_DIVH2             (0x00100000)
+
+#define CPG_ISP_DDIV2_DIVI_SET_MSK          (0x00000003)
+#define CPG_ISP_DDIV2_DIVI_SET_SHIFT        (0)
+#define CPG_ISP_DDIV2_DIVI_SET_MAX          (3)
+#define CPG_ISP_DDIV2_DIVI_SET_MIN          (0)
+#define CPG_ISP_DDIV2_DIVJ_SET_MSK          (0x00000003)
+#define CPG_ISP_DDIV2_DIVJ_SET_SHIFT        (4)
+#define CPG_ISP_DDIV2_DIVJ_SET_MAX          (3)
+#define CPG_ISP_DDIV2_DIVJ_SET_MIN          (0)
+#define CPG_ISP_DDIV2_DIVM_SET_MSK          (0x00000003)
+#define CPG_ISP_DDIV2_DIVM_SET_SHIFT        (8)
+#define CPG_ISP_DDIV2_DIVM_SET_MAX          (3)
+#define CPG_ISP_DDIV2_DIVM_SET_MIN          (0)
+#define CPG_ISP_DDIV2_WEN_DIVI              (0x00010000)
+#define CPG_ISP_DDIV2_WEN_DIVJ              (0x00100000)
+#define CPG_ISP_DDIV2_WEN_DIVM              (0x01000000)
+
+#define CPG_ISP_DSEL_SELH                   (0x00000001)        /** RBIA, CMIA core - 533MHz */
+#define CPG_ISP_DSEL_SELH2                  (0x00000010)        /** CIF core - 533MHz */
+#define CPG_ISP_DSEL_SELI                   (0x00000100)        /** BIMA_CLK, ICB_BIMA_CLK - 533MHz */
+#define CPG_ISP_DSEL_WEN_SELH               (0x00010000)
+#define CPG_ISP_DSEL_WEN_SELH2              (0x00100000)
+#define CPG_ISP_DSEL_WEN_SELI               (0x01000000)
+
+#define CPG_CLKSTATUS_DIVA                  (0x00000001)
+#define CPG_CLKSTATUS_DIVB                  (0x00000002)
+#define CPG_CLKSTATUS_DIVD                  (0x00000004)
+#define CPG_CLKSTATUS_DIVE                  (0x00000008)
+#define CPG_CLKSTATUS_DIVF                  (0x00000010)
+#define CPG_CLKSTATUS_DIVG                  (0x00000020)
+#define CPG_CLKSTATUS_DIVNFI                (0x00000040)
+#define CPG_CLKSTATUS_DIVX                  (0x00000080)
+#define CPG_CLKSTATUS_DIVH                  (0x00000100)
+#define CPG_CLKSTATUS_DIVI                  (0x00000200)
+#define CPG_CLKSTATUS_DIVJ                  (0x00000400)
+#define CPG_CLKSTATUS_DIVM                  (0x00000800)
+#define CPG_CLKSTATUS_DIVH2                 (0x00001000)
+#define CPG_CLKSTATUS_SELB                  (0x00010000)
+#define CPG_CLKSTATUS_SELD                  (0x00020000)
+#define CPG_CLKSTATUS_SELE                  (0x00040000)
+#define CPG_CLKSTATUS_SELF                  (0x00080000)
+#define CPG_CLKSTATUS_SELG                  (0x00100000)
+#define CPG_CLKSTATUS_SELNFI                (0x00200000)
+#define CPG_CLKSTATUS_SELH                  (0x01000000)
+#define CPG_CLKSTATUS_SELH2                 (0x02000000)
+#define CPG_CLKSTATUS_SELI                  (0x04000000)
+
+#define CPG_SDIEMM_SSEL_SELSDI              (0x00000001)
+#define CPG_SDIEMM_SSEL_WEN_SELSDI          (0x00010000)
+
+#define CPG_STG_SDIV_DIVSTG_SET_MSK         (0x00000003)
+#define CPG_STG_SDIV_DIVSTG_SET_SHIFT       (0)
+#define CPG_STG_SDIV_DIVSTG_SET_MAX         (3)
+#define CPG_STG_SDIV_DIVSTG_SET_MIN         (0)
+#define CPG_STG_SDIV_WEN_DIVSTG             (0x00010000)
+
+#define CPG_STGCIF_SSEL_SELSTG0             (0x00000001)
+#define CPG_STGCIF_SSEL_SELCIF_SET_MSK      (0x00000003)
+#define CPG_STGCIF_SSEL_SELCIF_SET_SHIFT    (8)
+#define CPG_STGCIF_SSEL_SELCIF_SET_MAX      (2)
+#define CPG_STGCIF_SSEL_SELCIF_SET_MIN      (0)
+#define CPG_STGCIF_SSEL_WEN_SESTG0          (0x00010000)
+#define CPG_STGCIF_SSEL_WEN_SELCIF          (0x01000000)
+
+#define CPG_DISP_SDIV1_DIVR_SET_MSK         (0x0000001F)
+#define CPG_DISP_SDIV1_DIVR_SET_SHIFT       (8)
+#define CPG_DISP_SDIV1_DIVR_SET_MAX         (0x1F)
+#define CPG_DISP_SDIV1_DIVR_SET_MIN         (0)
+#define CPG_DISP_SDIVI_WEN_DIVR             (0x01000000)
+
+#define CPG_DISP_SDIV2_DIVLCILP_SET_MSK     (0x0000007F)
+#define CPG_DISP_SDIV2_DIVLCILP_SET_SHIFT   (0)
+#define CPG_DISP_SDIV2_DIVLCILP_SET_MAX     (0x7F)
+#define CPG_DISP_SDIV2_DIVLCILP_SET_MIN     (0)
+#define CPG_DISP_SDIV2_WEN_DIVLCILP         (0x00010000)
+
+#define CPG_DISP_SSEL1_SELR                 (0x00000100)        /** HDMI - DIV R/2 */
+#define CPG_DISP_SSEL1_SELS1                (0x00001000)        /** LCI - PLL7 */
+#define CPG_DISP_SSEL1_WEN_SELR             (0x01000000)
+#define CPG_DISP_SSEL1_WEN_SELS1            (0x10000000)
+
+#define CPG_DISP_SSEL2_SELS2_SET_MSK        (0x00000003)
+#define CPG_DISP_SSEL2_SELS2_SET_SHIFT      (0)
+#define CPG_DISP_SSEL2_SELS2_SET_MAX        (2)
+#define CPG_DISP_SSEL2_SELS2_SET_MIN        (0)
+#define CPG_DISP_SSEL2_WEN_SELS2            (0x00010000)
+
+#define CPG_GMCLK_SDIV_DIVT_SET_MSK         (0x0000000F)
+#define CPG_GMCLK_SDIV_DIVT_SET_SHIFT       (0)
+#define CPG_GMCLK_SDIV_DIVT_SET_MAX         (12)
+#define CPG_GMCLK_SDIV_DIVT_SET_MIN         (0)
+#define CPG_GMCLK_SDIV_DIVU_SET_MSK         (0x0000000F)
+#define CPG_GMCLK_SDIV_DIVU_SET_SHIFT       (8)
+#define CPG_GMCLK_SDIV_DIVU_SET_MAX         (12)
+#define CPG_GMCLK_SDIV_DIVU_SET_MIN         (0)
+#define CPG_GMCLK_SDIV_WEN_DIVT             (0x00010000)
+#define CPG_GMCLK_SDIV_WEN_DIVU             (0x01000000)
+
+#define CPG_GMCLK_SSEL_SELT_SET_MSK         (0x00000003)
+#define CPG_GMCLK_SSEL_SELT_SET_SHIFT       (0)
+#define CPG_GMCLK_SSEL_SELT_SET_MAX         (3)
+#define CPG_GMCLK_SSEL_SELT_SET_MIN         (0)
+#define CPG_GMCLK_SSEL_SELU_SET_MSK         (0x00000003)
+#define CPG_GMCLK_SSEL_SETU_SET_SHIFT       (8)
+#define CPG_GMCLK_SSEL_SETU_SET_MAX         (3)
+#define CPG_GMCLK_SSEL_SETU_SET_MIN         (0)
+#define CPG_GMCLK_SSEL_WEN_SELT             (0x00010000)
+#define CPG_GMCLK_SSEL_WEN_SELU             (0x01000000)
+
+#define CPG_MTR_SSEL_SELMTR_SET_MSK         (0x00000003)
+#define CPG_MTR_SSEL_SELMTR_SET_SHIFT       (0)
+#define CPG_MTR_SSEL_SELMTR_SET_MAX         (2)
+#define CPG_MTR_SSEL_SELMTR_SET_MIN         (0)
+#define CPG_MTR_SSEL_WEN_SELMTR             (0x00010000)
+
+#define CPG_URT_RCLK_SDIV_DIVW_SET_MSK      (0x00000007)
+#define CPG_URT_RCLK_SDIV_DIVW_SET_SHIFT    (0)
+#define CPG_URT_RCLK_SDIV_DIVW_SET_MAX      (6)
+#define CPG_URT_RCLK_SDIV_DIVW_SET_MIN      (0)
+#define CPG_URT_RCLK_SDIV_WEN_DIVW          (0x00010000)
+
+#define CPG_URT_RCLK_SSEL_SELW0             (0x00000001)        /** UART0 - DIV W */
+#define CPG_URT_RCLK_SSEL_SELW1             (0x00000010)        /** UART1 - DIV W */
+#define CPG_URT_RCLK_SSEL_WEN_SELW0         (0x00010000)
+#define CPG_URT_RCLK_SSEL_WEN_SELW1         (0x00100000)
+
+#define CPG_CSI_RCLK_SSEL_SELCSI0           (0x00000001)        /** CSI0 - 48MHz */
+#define CPG_CSI_RCLK_SSEL_SELCSI1           (0x00000002)        /** CSI1 - 48MHz */
+#define CPG_CSI_RCLK_SSEL_SELCSI2           (0x00000004)        /** CSI2 - 48MHz */
+#define CPG_CSI_RCLK_SSEL_SELCSI3           (0x00000008)        /** CSI3 - 48MHz */
+#define CPG_CSI_RCLK_SSEL_SELCSI4           (0x00000010)        /** CSI4 - 48MHz */
+#define CPG_CSI_RCLK_SSEL_SELCSI5           (0x00000020)        /** CSI5 - 48MHz */
+#define CPG_CSI_RCLK_SSEL_WEN_SELCSI0       (0x00010000)
+#define CPG_CSI_RCLK_SSEL_WEN_SELCSI1       (0x00020000)
+#define CPG_CSI_RCLK_SSEL_WEN_SELCSI2       (0x00040000)
+#define CPG_CSI_RCLK_SSEL_WEN_SELCSI3       (0x00080000)
+#define CPG_CSI_RCLK_SSEL_WEN_SELCSI4       (0x00100000)
+#define CPG_CSI_RCLK_SSEL_WEN_SELCSI5       (0x00200000)
+
+                                                            /**         1,           2,           3,                4,           5,         6,          7,           8,               9,              10,              11,              12,              13,              14,              15,                        16,                         17,              18,                              19,              20,           21,                          22,             23,          24,          25,                26,                     27, */
+#define CPG_CLK_ON_CLK0_ON                  (0x00000001)        /**         -,   CST_TRACE,   SDI0_ACLK,         PCI_ACLK,     SDT_CLK,  HMI_PCLK,    AUI_CLK,    ATGA_CLK, CPERI_GRPA_PCLK, CPERI_GRPB_PCLK, CPERI_GRPC_PCLK, CPERI_GRPD_PCLK, CPERI_GRPE_PCLK, CPERI_GRPF_PCLK, CPERI_GRPG_PCLK,     ICB_ACLK1 ICB_GIC_CLK,              ICB_DRPA_ACLK,      ICB_MPCLK3,                        CA53_CLK, DRPA_ACLK(MCLK),    DRPB_ACLK,       CR8_CLK CR8_PERIPHCLK, RAMB_ACLK[3:0], CIMA_CLKAPB, BIMA_CLKAPB,                 -, MMC_CORE_DDRC_CORE_CLK, */
+#define CPG_CLK_ON_CLK1_ON                  (0x00000002)        /**   SYS_CLK,  CST_SB_CLK,  SDI0_IMCLK,      PCI_CLK_PMU,  SDT_CLKAPB,         -, AUI_CLKAXI, ATGA_CLKAPB,               -,               -,               -,               -,               -,               -, CPERI_GRPH_PCLK,                         -,                          -,    ICB_CIMA_CLK,                       CA53_ACLK,       DRPA_DCLK,    DRPB_DCLK, CR8_ACLK_MSTR CR8_ACLK_TCMS,      DMAB_ACLK,    CIMA_CLK,    BIMA_CLK,       TRFA_CLK533,               MMC_ACLK, */
+#define CPG_CLK_ON_CLK2_ON                  (0x00000004)        /**  PFC_PCLK, CST_AHB_CLK, SDI0_IMCLK2,      PCI_APB_CLK,   SDT_CLK48,         -, AUI_CLKAPB,    ATGB_CLK,               -,               -,               -,               -,               -,               -,               -,                ICB_MPCLK1,                          -,    ICB_CIMB_CLK, CA53_APCLK_DBG CST_APB_CA53_CLK,    DRPA_INITCLK, DRPB_INITCLK,      CR8_PCLK CR8_ACLK_LLPP,              -,    CIMB_CLK,           -,       TRFA_CLK400,               MMC_PCLK, */
+#define CPG_CLK_ON_CLK3_ON                  (0x00000008)        /**  MHU_PCLK, CST_APB_CR8, SDI0_CLK_HS,                -,     GRP_CLK,         -,     AUMCLK, ATGB_CLKAPB,               -,               -,               -,               -,               -,               -,               -,                ICB_SPCLK1,                          -,               -, CA53_ATCLK CST_CS_CLK CR8_ATCLK,               -,            -,                           -,              -,    FAFA_CLK,    FAFB_CLK,          TRFB_CLK,                      -, */
+#define CPG_CLK_ON_CLK4_ON                  (0x00000010)        /**  PMC_CORE,  CST_ATB_SB,   SDI1_ACLK,       USB_ACLK_H,  CIF_P0_CLK,         -,     GMCLK0,    JOG0_CLK,      TIM_CLK[0],      TIM_CLK[8],     TIM_CLK[16],     TIM_CLK[24],      PWM_CLK[0],      PWM_CLK[8],        URT_PCLK,                 ICB_CLK48, ICB_RFX_ACLK ICB_RFX_PCLK5,               -, CA53_TSCLK CST_TS_CLK CR8_TSCLK,               -,            -,                           -,       RBIA_CLK,  STG_CLKAXI,     FCD_CLK,           RIM_CLK,             DDI_APBCLK, */
+#define CPG_CLK_ON_CLK5_ON                  (0x00000020)        /**   GIC_CLK,           -,  SDI1_IMCLK,       USB_ACLK_P,  CIF_P1_CLK,         -,     GMCLK1, JOG0_CLKAPB,      TIM_CLK[1],      TIM_CLK[9],     TIM_CLK[17],     TIM_CLK[25],      PWM_CLK[1],      PWM_CLK[9],      URT_CLK[0],               ICB_CLK48_2,                          -,               -,                  CA53_APCLK_REG,               -,            -,                           -,    RBIA_CLKAPB,    STG_CLK0,  FCD_CLKAXI, VCD_ACLK VCD_PCLK,                      -, */
+#define CPG_CLK_ON_CLK6_ON                  (0x00000040)        /** RAMA_ACLK,           -, SDI1_IMCLK2,         USB_PCLK, CIF_APB_CLK,         -,          -,    JOG1_CLK,      TIM_CLK[2],     TIM_CLK[10],     TIM_CLK[18],     TIM_CLK[26],      PWM_CLK[2],     PWM_CLK[10],      URT_CLK[1],               ICB_CLK48_3,             ICB_RBIA_ACLK5,               -,                               -,               -,            -,                           -,              -,           -,           -,                 -,                      -, */
+#define CPG_CLK_ON_CLK7_ON                  (0x00000080)        /**  ROM_ACLK,           -, SDI1_CLK_HS,                -,  CIF_REFCLK,         -,          -, JOG1_CLKAPB,      TIM_CLK[3],     TIM_CLK[11],     TIM_CLK[19],     TIM_CLK[27],      PWM_CLK[3],     PWM_CLK[11],               -, ICB_CLK48_4L ICB_CLK48_4R,                          -,               -,                               -,               -,            -,                           -,              -,           -,           -,                 -,                      -, */
+#define CPG_CLK_ON_CLK8_ON                  (0x00000100)        /**  SEC_ACLK,           -,    EMM_ACLK, ETH0_CLK_AXI CHI,  DCI_CLKAXI,  LCI_PCLK,   MTR_CLK0,   SEQ_CLK48,      TIM_CLK[4],     TIM_CLK[12],     TIM_CLK[20],     TIM_CLK[28],      PWM_CLK[4],     PWM_CLK[12],      CSI_CLK[0],                         -,               ICB_MMC_ACLK,    ICB_BIMA_CLK,                               -,               -,            -,                           -,       RBIB_CLK,           -,           -,          JPG0_CLK,                      -, */
+#define CPG_CLK_ON_CLK9_ON                  (0x00000200)        /**  SEC_PCLK,           -,   EMM_IMCLK,    ETH0_CLK_GPTP,  DCI_CLKAPB,  LCI_ACLK,   MTR_CLK1,  SEQ_CLKAXI,      TIM_CLK[5],     TIM_CLK[13],     TIM_CLK[21],     TIM_CLK[29],      PWM_CLK[5],     PWM_CLK[13],      CSI_CLK[1],               ICB_CLK48_5,                          -,  ICB_FCD_CLKAXI,                               -,               -,            -,                           -,    RBIB_CLKAPB,           -,           -,         JPG0_ACLK,                      -, */
+#define CPG_CLK_ON_CLK10_ON                 (0x00000400)        /**  SEC_TCLK,           -,  EMM_IMCLK2,                -,           -,  LCI_VCLK, MTR_CLKAPB,  SEQ_CLKAPB,      TIM_CLK[6],     TIM_CLK[14],     TIM_CLK[22],     TIM_CLK[30],      PWM_CLK[6],     PWM_CLK[14],      CSI_CLK[2],        ICB_CST_ATB_SB_CLK,                          -, ICB_TRFA_CLK533,                               -,               -,            -,                           -,  RBIB_CLKRSP48,           -,           -,          JPG1_CLK,                      -, */
+#define CPG_CLK_ON_CLK11_ON                 (0x00000800)        /** DMAA_ACLK,           -,  EMM_CLK_HS,                -,           -, LCI_LPCLK,          -,           -,      TIM_CLK[7],     TIM_CLK[15],     TIM_CLK[23],     TIM_CLK[31],      PWM_CLK[7],     PWM_CLK[15],      CSI_CLK[3],            ICB_CST_CS_CLK,                          -,    ICB_VD_ACLK4,                               -,               -,            -,                           -,              -,           -,           -,         JPG1_ACLK,                      -, */
+#define CPG_CLK_ON_CLK12_ON                 (0x00001000)        /**  OTP_PCLK,           -,    NFI_ACLK,                -, DCI_CLKDCI2,         -,    GFT_CLK, SYC_CNT_CLK,     IIC_PCLK[0],     IIC_PCLK[1],     WDT_PCLK[0],     WDT_PCLK[2],               -,               -,      CSI_CLK[4],              ICB_CLK100_1,                          -,      ICB_MPCLK4,                               -,               -,            -,                           -,              -,           -,           -,                 -,                      -, */
+#define CPG_CLK_ON_CLK13_ON                 (0x00002000)        /**  OTP_SCLK,           -,  NFI_NF_CLK,                -,           -,         -, GFT_CLKAPB,    PSC_PCLK,               -,               -,      WDT_CLK[0],      WDT_CLK[2],               -,               -,      CSI_CLK[5],          ICB_ETH0_CLK_AXI,                          -,   ICB_VCD_PCLK4,                               -,               -,            -,                           -,              -,           -,           -,                 -,                      -, */
+#define CPG_CLK_ON_CLK14_ON                 (0x00004000)        /** TSU0_PCLK,           -,           -,                -,           -,         -,   GFT_MCLK,           -,               -,               -,     WDT_PCLK[1],               -,               -,               -,               -,            ICB_DCI_CLKAXI,                          -,               -,                               -,               -,            -,                           -,              -,           -,           -,                 -,                      -, */
+#define CPG_CLK_ON_CLK15_ON                 (0x00008000)        /** TSU1_PCLK,           -,           -,                -,           -,         -,          -,           -,               -,               -,      WDT_CLK[1],               -,               -,               -,               -,           ICB_SYC_CNT_CLK,                          -,               -,                               -,               -,            -,                           -,              -,           -,           -,                 -,                      -, */
+#define CPG_CLK_ON_WEN_CLK0_ON              (0x00010000)
+#define CPG_CLK_ON_WEN_CLK1_ON              (0x00020000)
+#define CPG_CLK_ON_WEN_CLK2_ON              (0x00040000)
+#define CPG_CLK_ON_WEN_CLK3_ON              (0x00080000)
+#define CPG_CLK_ON_WEN_CLK4_ON              (0x00100000)
+#define CPG_CLK_ON_WEN_CLK5_ON              (0x00200000)
+#define CPG_CLK_ON_WEN_CLK6_ON              (0x00400000)
+#define CPG_CLK_ON_WEN_CLK7_ON              (0x00800000)
+#define CPG_CLK_ON_WEN_CLK8_ON              (0x01000000)
+#define CPG_CLK_ON_WEN_CLK9_ON              (0x02000000)
+#define CPG_CLK_ON_WEN_CLK10_ON             (0x04000000)
+#define CPG_CLK_ON_WEN_CLK11_ON             (0x08000000)
+#define CPG_CLK_ON_WEN_CLK12_ON             (0x10000000)
+#define CPG_CLK_ON_WEN_CLK13_ON             (0x20000000)
+#define CPG_CLK_ON_WEN_CLK14_ON             (0x40000000)
+#define CPG_CLK_ON_WEN_CLK15_ON             (0x80000000)
+
+#define CPG_WDT_RST_WDT_RST0                (0x00000001)
+#define CPG_WDT_RST_WDT_RST1                (0x00000002)
+#define CPG_WDT_RST_WDT_RST2                (0x00000004)
+#define CPG_WDT_RST_WEN_WDT_RST0            (0x00010000)
+#define CPG_WDT_RST_WEN_WDT_RST1            (0x00020000)
+#define CPG_WDT_RST_WEN_WDT_RST2            (0x00040000)
+
+#define CPG_RST_MSK_WARM0_MSK               (0x00000001)
+#define CPG_RST_MSK_WARM1_MSK               (0x00000002)
+#define CPG_RST_MSK_DBG0_MSK                (0x00000004)
+#define CPG_RST_MSK_DBG1_MSK                (0x00000008)
+#define CPG_RST_MSK_WEN_WARM0_MSK           (0x00010000)
+#define CPG_RST_MSK_WEN_WARM1_MSK           (0x00020000)
+#define CPG_RST_MSK_WEN_DBG0_MSK            (0x00040000)
+#define CPG_RST_MSK_WEN_DBG1_MSK            (0x00080000)
+
+
+#define CPG_RST_UNIT0_RSTB                  (0x00000001)
+#define CPG_RST_UNIT1_RSTB                  (0x00000002)
+#define CPG_RST_UNIT2_RSTB                  (0x00000004)
+#define CPG_RST_UNIT3_RSTB                  (0x00000008)
+#define CPG_RST_UNIT4_RSTB                  (0x00000010)
+#define CPG_RST_UNIT5_RSTB                  (0x00000020)
+#define CPG_RST_UNIT6_RSTB                  (0x00000040)
+#define CPG_RST_UNIT7_RSTB                  (0x00000080)
+#define CPG_RST_UNIT8_RSTB                  (0x00000100)
+#define CPG_RST_UNIT9_RSTB                  (0x00000200)
+#define CPG_RST_UNIT10_RSTB                 (0x00000400)
+#define CPG_RST_UNIT11_RSTB                 (0x00000800)
+#define CPG_RST_UNIT12_RSTB                 (0x00001000)
+#define CPG_RST_UNIT13_RSTB                 (0x00002000)
+#define CPG_RST_UNIT14_RSTB                 (0x00004000)
+#define CPG_RST_UNIT15_RSTB                 (0x00008000)
+#define CPG_RST_WEN_UNIT0_RSTB              (0x00010000)
+#define CPG_RST_WEN_UNIT1_RSTB              (0x00020000)
+#define CPG_RST_WEN_UNIT2_RSTB              (0x00040000)
+#define CPG_RST_WEN_UNIT3_RSTB              (0x00080000)
+#define CPG_RST_WEN_UNIT4_RSTB              (0x00100000)
+#define CPG_RST_WEN_UNIT5_RSTB              (0x00200000)
+#define CPG_RST_WEN_UNIT6_RSTB              (0x00400000)
+#define CPG_RST_WEN_UNIT7_RSTB              (0x00800000)
+#define CPG_RST_WEN_UNIT8_RSTB              (0x01000000)
+#define CPG_RST_WEN_UNIT9_RSTB              (0x02000000)
+#define CPG_RST_WEN_UNIT10_RSTB             (0x04000000)
+#define CPG_RST_WEN_UNIT11_RSTB             (0x08000000)
+#define CPG_RST_WEN_UNIT12_RSTB             (0x10000000)
+#define CPG_RST_WEN_UNIT13_RSTB             (0x20000000)
+#define CPG_RST_WEN_UNIT14_RSTB             (0x40000000)
+#define CPG_RST_WEN_UNIT15_RSTB             (0x80000000)
+
+
+#define CPG_RST_MON_MHU                     (0x00000001)
+#define CPG_RST_MON_GIC                     (0x00000002)
+#define CPG_RST_MON_RAMA                    (0x00000004)
+#define CPG_RST_MON_ROM                     (0x00000008)
+#define CPG_RST_MON_DMAA                    (0x00000010)
+#define CPG_RST_MON_SEC                     (0x00000020)
+#define CPG_RST_MON_SDI0                    (0x00000040)
+#define CPG_RST_MON_SDI1                    (0x00000080)
+#define CPG_RST_MON_EMM                     (0x00000100)
+#define CPG_RST_MON_NFI_1                   (0x00000200)
+#define CPG_RST_MON_NFI_2                   (0x00000400)
+#define CPG_RST_MON_ETH0                    (0x00000800)
+#define CPG_RST_MON_SYC                     (0x00002000)
+#define CPG_RST_MON_DRPA                    (0x00004000)
+#define CPG_RST_MON_DRPB                    (0x00008000)
+#define CPG_RST_MON_DMAB                    (0x00010000)
+#define CPG_RST_MON_RAMB                    (0x00020000)
+#define CPG_RST_MON_VCD                     (0x00040000)
+#define CPG_RST_MON_WDT0                    (0x00080000)
+#define CPG_RST_MON_WDT1                    (0x00100000)
+#define CPG_RST_MON_WDT2                    (0x00200000)
+#define CPG_RST_MON_PWM_0                   (0x00400000)
+#define CPG_RST_MON_PWM_1                   (0x00800000)
+#define CPG_RST_MON_CSI_1                   (0x01000000)
+#define CPG_RST_MON_CSI_2                   (0x02000000)
+#define CPG_RST_MON_URT                     (0x04000000)
+#define CPG_RST_MON_JPG0                    (0x10000000)
+#define CPG_RST_MON_JPG1                    (0x20000000)
+
+#define CPG_RST_MON_SYSTEM_ON   \
+    (CPG_RST_MON_CSI_2 | CPG_RST_MON_CSI_1 | CPG_RST_MON_PWM_1 | \
+     CPG_RST_MON_PWM_0 | CPG_RST_MON_SYC | CPG_RST_MON_NFI_2 | \
+     CPG_RST_MON_NFI_1 | CPG_RST_MON_SDI1 | CPG_RST_MON_SDI0 )
+
+#define CPG_PD_RST_MEM_RSTB                 (0x00000001)
+#define CPG_PD_RST_VD0_RSTB                 (0x00000002)
+#define CPG_PD_RST_VD1A_RSTB                (0x00000004)
+#define CPG_PD_RST_VD1B_RSTB                (0x00000008)
+#define CPG_PD_RST_RFX_RSTB                 (0x00000010)
+#define CPG_PD_RST_WEN_MEM_RSTB             (0x00010000)
+#define CPG_PD_RST_WEN_VD0_RSTB             (0x00020000)
+#define CPG_PD_RST_WEN_VD1A_RSTB            (0x00040000)
+#define CPG_PD_RST_WEN_VD1B_RSTB            (0x00080000)
+#define CPG_PD_RST_WEN_RFX_RSTB             (0x00100000)
+
+#define CPG_PLL_MIN                         (1)
+#define CPG_PLL_MAX                         (7)
+
+#define CPG_CLK_ON_REG_MIN                  (1)
+#define CPG_CLK_ON_REG_MAX                  (27)
+
+#define CPG_RST_REG_MIN                     (1)
+#define CPG_RST_REG_MAX                     (15)
+
+typedef struct
+{
+    union
+    {
+        uint32_t        word;
+        struct
+        {
+            uint32_t    :2;
+            uint32_t    enable:1;
+            uint32_t    :1;
+            uint32_t    mode:2;
+            uint32_t    :26;
+        }bit;
+    }ssc;
+    union
+    {
+        uint32_t        word[2];
+        struct
+        {
+            uint32_t    p:6;
+            uint32_t    m:10;
+            uint32_t    k:16;
+            uint32_t    s:3;
+            uint32_t    :5;
+            uint32_t    mrr:6;
+            uint32_t    :2;
+            uint32_t    mfr:8;
+            uint32_t    :8;
+        } bit;
+    } clk;
+} st_cpg_pll_param_t;
+
+typedef enum
+{
+    CPG_ERROR_ARGUMENT               = -201,
+    CPG_ERROR_NO_REGISTER            = -202,
+    CPG_ERROR_NULL_POINTER           = -203,
+    CPG_ERROR_PLL_TURN_MODE_TIMEOUT  = -204,
+    CPG_ERROR_PLL_ACTIVE             = -205,
+    CPG_ERROR_PLL_STANDBY            = -206,
+    CPG_ERROR_TURN_RESET_TIMEOUT     = -207,
+    CPG_ERROR_PLL_NOT_ACTIVE         = -280,
+    CPG_ERROR_PLL_NOT_STANDBY        = -290
+} e_cpg_error_code_t;
+
+typedef enum
+{
+    CPG_PLL_1 = 1,
+    CPG_PLL_2 = 2,
+    CPG_PLL_3 = 3,
+    CPG_PLL_4 = 4,
+    CPG_PLL_6 = 6,
+    CPG_PLL_7 = 7
+} e_cpg_pll_num_t;
+
+typedef enum
+{
+    CPG_DDIV_CA53 = 0,
+    CPG_DDIV_SYS,
+    CPG_DDIV_CR8REF,
+    CPG_DDIV_NFI,
+    CPG_DDIV_MMCDDI,
+    CPG_DSEL_CLK48,
+    CPG_DDIV_ISP1,
+    CPG_DDIV_ISP2,
+    CPG_DSEL_ISP,
+    CPG_SSEL_SDIEMM = 64,
+    CPG_SDIV_STG,
+    CPG_SSEL_STGCIF,
+    CPG_SDIV_DISP1,
+    CPG_SDIV_DISP2,
+    CPG_SSEL_DISP1,
+    CPG_SSEL_DISP2,
+    CPG_SDIV_GMCLK,
+    CPG_SSEL_GMCLK,
+    CPG_SSEL_MTR,
+    CPG_SDIV_URT_RCLK,
+    CPG_SSEL_URT_RCLK,
+    CPG_SSEL_CSI_RCLK
+} e_cpg_divsel_t;
+
+/** prototype defined **/
+
+int32_t r8arzv2m_cpg_setClockCtrl(void __iomem *base, uint8_t reg_num, uint16_t target, uint16_t set_value);
+int32_t r8arzv2m_cpg_getClockCtrl(void __iomem *base, uint8_t reg_num, uint16_t target);
+int32_t CPG_SetResetCtrl(void __iomem *base, uint8_t reg_num, uint16_t target, uint16_t set_value);
+int32_t CPG_WaitResetMon(void __iomem *base, uint32_t timeout_c, uint32_t msk, uint32_t val);
+
+
+
+#endif /* RDK_CMN_CPG_H */
+
+#endif /* __DT_BINDINGS_CLOCK_R8ARZV2M_CPG_MSSR_H__ */
diff --git a/drivers/clk/renesas/r9a09g011gbg-cpg-mssr.c b/drivers/clk/renesas/r9a09g011gbg-cpg-mssr.c
index 9f595c3..694b6cf 100644
--- a/drivers/clk/renesas/r9a09g011gbg-cpg-mssr.c
+++ b/drivers/clk/renesas/r9a09g011gbg-cpg-mssr.c
@@ -10,242 +10,158 @@
  * Copyright (C) 2015 Renesas Electronics Corp.
  */
 
+#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/init.h>
+#include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/soc/renesas/rcar-rst.h>
 
 #include <dt-bindings/clock/r9a09g011gbg-cpg-mssr.h>
+#include "r9a09g011-cpg-mssr.h"
 
-#include "renesas-cpg-mssr.h"
+#include "renesas-cpg-clkon.h"
 #include "rcar-gen3-cpg.h"
 
+#define CPG_REG_WEN_SHIFT           (16)
+#define CPG_SET_DATA_MASK           (0x0000FFFFUL)
+
 enum clk_ids {
        /* Core Clock Outputs exported to DT */
-       LAST_DT_CORE_CLK = R8A774C0_CLK_CANFD,
+//     LAST_DT_CORE_CLK = R8A774C0_CLK_CANFD,
+       LAST_DT_CORE_CLK = 0,
 
        /* External Input Clocks */
-       CLK_EXTAL,
+//     CLK_EXTAL,
 
        /* Internal Core Clocks */
        CLK_MAIN,
-       CLK_PLL0,
-       CLK_PLL1,
-       CLK_PLL3,
-       CLK_PLL0D4,
-       CLK_PLL0D6,
-       CLK_PLL0D8,
-       CLK_PLL0D20,
-       CLK_PLL0D24,
-       CLK_PLL1D2,
-       CLK_PE,
-       CLK_S0,
-       CLK_S1,
-       CLK_S2,
-       CLK_S3,
-       CLK_SDSRC,
-       CLK_RINT,
-       CLK_OCO,
+       CLK_MAIN_2,
+       CLK_MAIN_24,
+//     CLK_PLL1,
+       CLK_PLL2,
+       CLK_PLL2_2,
+       CLK_PLL2_8,
+       CLK_PLL2_16,
+//     CLK_DIV_A,
+       CLK_DIV_B,
+       CLK_DIV_D,
+       CLK_DIV_E,
+       CLK_SEL_B,
+       CLK_SEL_D,
+       CLK_SEL_E,
+#if 0//static defined is disabled
+       CLK_SEL_CSI0,
+       CLK_SEL_CSI2,
+       CLK_SEL_W0,
+       CLK_SEL_SDI0,
+#endif
 
        /* Module Clocks */
        MOD_CLK_BASE
 };
 
 static const struct cpg_core_clk r8arzv2m_core_clks[] __initconst = {
-       /* External Clock Inputs */
-       DEF_INPUT("extal",     CLK_EXTAL),
 
        /* Internal Core Clocks */
-       DEF_BASE(".main",      CLK_MAIN, CLK_TYPE_GEN3_MAIN,       CLK_EXTAL),
-       DEF_BASE(".pll1",      CLK_PLL1, CLK_TYPE_GEN3_PLL1,       CLK_MAIN),
-       DEF_BASE(".pll3",      CLK_PLL3, CLK_TYPE_GEN3_PLL3,       CLK_MAIN),
-
-       DEF_FIXED(".pll0",     CLK_PLL0,           CLK_MAIN,       1, 100),
-       DEF_FIXED(".pll0d4",   CLK_PLL0D4,         CLK_PLL0,       4, 1),
-       DEF_FIXED(".pll0d6",   CLK_PLL0D6,         CLK_PLL0,       6, 1),
-       DEF_FIXED(".pll0d8",   CLK_PLL0D8,         CLK_PLL0,       8, 1),
-       DEF_FIXED(".pll0d20",  CLK_PLL0D20,        CLK_PLL0,      20, 1),
-       DEF_FIXED(".pll0d24",  CLK_PLL0D24,        CLK_PLL0,      24, 1),
-       DEF_FIXED(".pll1d2",   CLK_PLL1D2,         CLK_PLL1,       2, 1),
-       DEF_FIXED(".pe",       CLK_PE,             CLK_PLL0D20,    1, 1),
-       DEF_FIXED(".s0",       CLK_S0,             CLK_PLL1,       2, 1),
-       DEF_FIXED(".s1",       CLK_S1,             CLK_PLL1,       3, 1),
-       DEF_FIXED(".s2",       CLK_S2,             CLK_PLL1,       4, 1),
-       DEF_FIXED(".s3",       CLK_S3,             CLK_PLL1,       6, 1),
-       DEF_FIXED(".sdsrc",    CLK_SDSRC,          CLK_PLL1,       2, 1),
-
-       DEF_DIV6_RO(".r",      CLK_RINT,           CLK_EXTAL, CPG_RCKCR, 32),
-
-       DEF_RATE(".oco",       CLK_OCO,            8 * 1000 * 1000),
-
-       /* Core Clock Outputs */
-       DEF_FIXED("za2",       R8A774C0_CLK_ZA2,   CLK_PLL0D24,    1, 1),
-       DEF_FIXED("za8",       R8A774C0_CLK_ZA8,   CLK_PLL0D8,     1, 1),
-       DEF_GEN3_Z("z2",       R8A774C0_CLK_Z2, CLK_TYPE_GEN3_Z2, CLK_PLL0, 4),
-       DEF_GEN3_Z("zg",       R8A774C0_CLK_ZG, CLK_TYPE_GEN3_ZG, CLK_PLL0, 8),
-       DEF_FIXED("ztr",       R8A774C0_CLK_ZTR,   CLK_PLL1,       6, 1),
-       DEF_FIXED("zt",        R8A774C0_CLK_ZT,    CLK_PLL1,       4, 1),
-       DEF_FIXED("zx",        R8A774C0_CLK_ZX,    CLK_PLL1,       3, 1),
-       DEF_FIXED("s0d1",      R8A774C0_CLK_S0D1,  CLK_S0,         1, 1),
-       DEF_FIXED("s0d3",      R8A774C0_CLK_S0D3,  CLK_S0,         3, 1),
-       DEF_FIXED("s0d6",      R8A774C0_CLK_S0D6,  CLK_S0,         6, 1),
-       DEF_FIXED("s0d12",     R8A774C0_CLK_S0D12, CLK_S0,        12, 1),
-       DEF_FIXED("s0d24",     R8A774C0_CLK_S0D24, CLK_S0,        24, 1),
-       DEF_FIXED("s1d1",      R8A774C0_CLK_S1D1,  CLK_S1,         1, 1),
-       DEF_FIXED("s1d2",      R8A774C0_CLK_S1D2,  CLK_S1,         2, 1),
-       DEF_FIXED("s1d4",      R8A774C0_CLK_S1D4,  CLK_S1,         4, 1),
-       DEF_FIXED("s2d1",      R8A774C0_CLK_S2D1,  CLK_S2,         1, 1),
-       DEF_FIXED("s2d2",      R8A774C0_CLK_S2D2,  CLK_S2,         2, 1),
-       DEF_FIXED("s2d4",      R8A774C0_CLK_S2D4,  CLK_S2,         4, 1),
-       DEF_FIXED("s3d1",      R8A774C0_CLK_S3D1,  CLK_S3,         1, 1),
-       DEF_FIXED("s3d2",      R8A774C0_CLK_S3D2,  CLK_S3,         2, 1),
-       DEF_FIXED("s3d4",      R8A774C0_CLK_S3D4,  CLK_S3,         4, 1),
-
-       DEF_GEN3_SD("sd0",     R8A774C0_CLK_SD0,   CLK_SDSRC,     0x0074),
-       DEF_GEN3_SD("sd1",     R8A774C0_CLK_SD1,   CLK_SDSRC,     0x0078),
-       DEF_GEN3_SD("sd3",     R8A774C0_CLK_SD3,   CLK_SDSRC,     0x026c),
-
-       DEF_FIXED("cl",        R8A774C0_CLK_CL,    CLK_PLL1,      48, 1),
-       DEF_FIXED("cp",        R8A774C0_CLK_CP,    CLK_EXTAL,      2, 1),
-       DEF_FIXED("cpex",      R8A774C0_CLK_CPEX,  CLK_EXTAL,      4, 1),
-
-       DEF_DIV6_RO("osc",     R8A774C0_CLK_OSC,   CLK_EXTAL, CPG_RCKCR,  8),
-
-       DEF_GEN3_PE("s0d6c",   R8A774C0_CLK_S0D6C, CLK_S0, 6, CLK_PE, 2),
-       DEF_GEN3_PE("s3d1c",   R8A774C0_CLK_S3D1C, CLK_S3, 1, CLK_PE, 1),
-       DEF_GEN3_PE("s3d2c",   R8A774C0_CLK_S3D2C, CLK_S3, 2, CLK_PE, 2),
-       DEF_GEN3_PE("s3d4c",   R8A774C0_CLK_S3D4C, CLK_S3, 4, CLK_PE, 4),
-
-       DEF_DIV6P1("canfd",    R8A774C0_CLK_CANFD, CLK_PLL0D6, 0x244),
-       DEF_DIV6P1("csi0",     R8A774C0_CLK_CSI0,  CLK_PLL1D2, 0x00c),
-       DEF_DIV6P1("mso",      R8A774C0_CLK_MSO,   CLK_PLL1D2, 0x014),
-
-       DEF_GEN3_RCKSEL("r",   R8A774C0_CLK_R, CLK_RINT, 1, CLK_OCO, 61 * 4),
+       DEF_RATE(".main",      CLK_MAIN,        48*1000*1000),
+       DEF_RATE(".main2",     CLK_MAIN_2,      24*1000*1000),
+       DEF_RATE(".main24",    CLK_MAIN_24,     2*1000*1000),
+       DEF_RATE(".pll2",      CLK_PLL2,        1600*1000*1000),
+       DEF_RATE(".pll2_2",    CLK_PLL2_2,      800*1000*1000),
+       DEF_RATE(".pll2_8",    CLK_PLL2_8,      200*1000*1000),
+       DEF_RATE(".pll2_16",   CLK_PLL2_16,     100*1000*1000),
+
+       DEF_DIV(".divb",     CLK_DIV_B,          CLK_PLL2,         4,
+               CPG_SYS_DDIV, CPG_SYS_DDIV_WEN_DIVB|CPG_SYS_DDIV_WEN_DIVE|CPG_SYS_DDIV_WEN_DIVD,
+               CPG_CLKSTATUS_DIVB|CPG_CLKSTATUS_DIVD|CPG_CLKSTATUS_DIVE, 0),
+       DEF_DIV(".divd",     CLK_DIV_D,          CLK_PLL2,         8,
+               CPG_SYS_DDIV, CPG_SYS_DDIV_WEN_DIVB|CPG_SYS_DDIV_WEN_DIVE|CPG_SYS_DDIV_WEN_DIVD,
+               CPG_CLKSTATUS_DIVB|CPG_CLKSTATUS_DIVD|CPG_CLKSTATUS_DIVE, 0),
+       DEF_DIV(".dive",     CLK_DIV_E,          CLK_PLL2,         16,
+               CPG_SYS_DDIV, CPG_SYS_DDIV_WEN_DIVB|CPG_SYS_DDIV_WEN_DIVE|CPG_SYS_DDIV_WEN_DIVD,
+               CPG_CLKSTATUS_DIVB|CPG_CLKSTATUS_DIVD|CPG_CLKSTATUS_DIVE, 0),
+       DEF_DIV(".selb",     CLK_SEL_B,          CLK_DIV_B,  1,
+               CPG_CLK48_DSEL, CPG_CLK48_DSEL_WEN_SELB, 0,     CPG_CLK48_DSEL_SELB),
+       DEF_DIV(".seld",     CLK_SEL_D,          CLK_DIV_D,  1,
+               CPG_CLK48_DSEL, CPG_CLK48_DSEL_WEN_SELD, 0,     CPG_CLK48_DSEL_SELD),
+       DEF_DIV(".sele",     CLK_SEL_E,          CLK_DIV_D,  1,
+               CPG_CLK48_DSEL, CPG_CLK48_DSEL_WEN_SELE, 0,     CPG_CLK48_DSEL_SELE),
+#if 0 //static defined is disabled
+       DEF_STATIC(".selcsi0",     CLK_SEL_CSI0,          CLK_MAIN,       1,
+               CPG_CSI_RCLK_SSEL, CPG_CSI_RCLK_SSEL_WEN_SELCSI0,       CPG_CSI_RCLK_SSEL_SELCSI0),
+       DEF_STATIC(".selcsi2",     CLK_SEL_CSI2,          CLK_MAIN,       1,
+               CPG_CSI_RCLK_SSEL, CPG_CSI_RCLK_SSEL_WEN_SELCSI2,       CPG_CSI_RCLK_SSEL_SELCSI2),
+       DEF_STATIC(".selw",     CLK_SEL_W0,               CLK_MAIN,       1,
+               CPG_URT_RCLK_SSEL, CPG_URT_RCLK_SSEL_WEN_SELW0,         0),
+       DEF_STATIC(".selsdi0",     CLK_SEL_SDI0,          CLK_PLL2,       2,
+               CPG_SDIEMM_SSEL,   CPG_SDIEMM_SSEL_WEN_SELSDI,          CPG_SDIEMM_SSEL_SELSDI),
+#endif
 };
 
 static const struct mssr_mod_clk r8arzv2m_mod_clks[] __initconst = {
-       DEF_MOD("3dge",                  112,   R8A774C0_CLK_ZG),
-       DEF_MOD("fdp1-0",                119,   R8A774C0_CLK_S0D1),
-       DEF_MOD("vcplf",                 130,   R8A774C0_CLK_S3D1),
-       DEF_MOD("vdpb",                  131,   R8A774C0_CLK_S3D1),
-       DEF_MOD("tmu4",                  121,   R8A774C0_CLK_S0D6C),
-       DEF_MOD("tmu3",                  122,   R8A774C0_CLK_S3D2C),
-       DEF_MOD("tmu2",                  123,   R8A774C0_CLK_S3D2C),
-       DEF_MOD("tmu1",                  124,   R8A774C0_CLK_S3D2C),
-       DEF_MOD("tmu0",                  125,   R8A774C0_CLK_CP),
-       DEF_MOD("scif5",                 202,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("scif4",                 203,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("scif3",                 204,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("scif1",                 206,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("scif0",                 207,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("msiof3",                208,   R8A774C0_CLK_MSO),
-       DEF_MOD("msiof2",                209,   R8A774C0_CLK_MSO),
-       DEF_MOD("msiof1",                210,   R8A774C0_CLK_MSO),
-       DEF_MOD("msiof0",                211,   R8A774C0_CLK_MSO),
-       DEF_MOD("sys-dmac2",             217,   R8A774C0_CLK_S3D1),
-       DEF_MOD("sys-dmac1",             218,   R8A774C0_CLK_S3D1),
-       DEF_MOD("sys-dmac0",             219,   R8A774C0_CLK_S3D1),
-
-       DEF_MOD("cmt3",                  300,   R8A774C0_CLK_R),
-       DEF_MOD("cmt2",                  301,   R8A774C0_CLK_R),
-       DEF_MOD("cmt1",                  302,   R8A774C0_CLK_R),
-       DEF_MOD("cmt0",                  303,   R8A774C0_CLK_R),
-       DEF_MOD("tpu",                   304,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("scif2",                 310,   R8A774C0_CLK_S3D4C),
-       DEF_MOD("sdif3",                 311,   R8A774C0_CLK_SD3),
-       DEF_MOD("sdif1",                 313,   R8A774C0_CLK_SD1),
-       DEF_MOD("sdif0",                 314,   R8A774C0_CLK_SD0),
-       DEF_MOD("pcie0",                 319,   R8A774C0_CLK_S3D1),
-       DEF_MOD("usb3-if0",              328,   R8A774C0_CLK_S3D1),
-       DEF_MOD("usb-dmac0",             330,   R8A774C0_CLK_S3D1),
-       DEF_MOD("usb-dmac1",             331,   R8A774C0_CLK_S3D1),
-
-       DEF_MOD("rwdt",                  402,   R8A774C0_CLK_R),
-       DEF_MOD("intc-ex",               407,   R8A774C0_CLK_CP),
-       DEF_MOD("intc-ap",               408,   R8A774C0_CLK_S0D3),
-
-       DEF_MOD("audmac0",               502,   R8A774C0_CLK_S1D2),
-       DEF_MOD("hscif4",                516,   R8A774C0_CLK_S3D1C),
-       DEF_MOD("hscif3",                517,   R8A774C0_CLK_S3D1C),
-       DEF_MOD("hscif2",                518,   R8A774C0_CLK_S3D1C),
-       DEF_MOD("hscif1",                519,   R8A774C0_CLK_S3D1C),
-       DEF_MOD("hscif0",                520,   R8A774C0_CLK_S3D1C),
-       DEF_MOD("thermal",               522,   R8A774C0_CLK_CP),
-       DEF_MOD("pwm",                   523,   R8A774C0_CLK_S3D4C),
-
-       DEF_MOD("fcpvd1",                602,   R8A774C0_CLK_S1D2),
-       DEF_MOD("fcpvd0",                603,   R8A774C0_CLK_S1D2),
-       DEF_MOD("fcpvb0",                607,   R8A774C0_CLK_S0D1),
-       DEF_MOD("fcpvi0",                611,   R8A774C0_CLK_S0D1),
-       DEF_MOD("fcpf0",                 615,   R8A774C0_CLK_S0D1),
-       DEF_MOD("fcpcs",                 619,   R8A774C0_CLK_S0D1),
-       DEF_MOD("vspd1",                 622,   R8A774C0_CLK_S1D2),
-       DEF_MOD("vspd0",                 623,   R8A774C0_CLK_S1D2),
-       DEF_MOD("vspb",                  626,   R8A774C0_CLK_S0D1),
-       DEF_MOD("vspi0",                 631,   R8A774C0_CLK_S0D1),
-
-       DEF_MOD("ehci0",                 703,   R8A774C0_CLK_S3D2),
-       DEF_MOD("hsusb",                 704,   R8A774C0_CLK_S3D2),
-       DEF_MOD("csi40",                 716,   R8A774C0_CLK_CSI0),
-       DEF_MOD("du1",                   723,   R8A774C0_CLK_S1D1),
-       DEF_MOD("du0",                   724,   R8A774C0_CLK_S1D1),
-       DEF_MOD("lvds",                  727,   R8A774C0_CLK_S2D1),
-
-       DEF_MOD("vin5",                  806,   R8A774C0_CLK_S1D2),
-       DEF_MOD("vin4",                  807,   R8A774C0_CLK_S1D2),
-       DEF_MOD("etheravb",              812,   R8A774C0_CLK_S3D2),
-
-       DEF_MOD("gpio6",                 906,   R8A774C0_CLK_S3D4),
-       DEF_MOD("gpio5",                 907,   R8A774C0_CLK_S3D4),
-       DEF_MOD("gpio4",                 908,   R8A774C0_CLK_S3D4),
-       DEF_MOD("gpio3",                 909,   R8A774C0_CLK_S3D4),
-       DEF_MOD("gpio2",                 910,   R8A774C0_CLK_S3D4),
-       DEF_MOD("gpio1",                 911,   R8A774C0_CLK_S3D4),
-       DEF_MOD("gpio0",                 912,   R8A774C0_CLK_S3D4),
-       DEF_MOD("can-fd",                914,   R8A774C0_CLK_S3D2),
-       DEF_MOD("can-if1",               915,   R8A774C0_CLK_S3D4),
-       DEF_MOD("can-if0",               916,   R8A774C0_CLK_S3D4),
-       DEF_MOD("i2c6",                  918,   R8A774C0_CLK_S3D2),
-       DEF_MOD("i2c5",                  919,   R8A774C0_CLK_S3D2),
-       DEF_MOD("adg",                   922,   R8A774C0_CLK_ZA8),
-       DEF_MOD("i2c-dvfs",              926,   R8A774C0_CLK_CP),
-       DEF_MOD("i2c4",                  927,   R8A774C0_CLK_S3D2),
-       DEF_MOD("i2c3",                  928,   R8A774C0_CLK_S3D2),
-       DEF_MOD("i2c2",                  929,   R8A774C0_CLK_S3D2),
-       DEF_MOD("i2c1",                  930,   R8A774C0_CLK_S3D2),
-       DEF_MOD("i2c0",                  931,   R8A774C0_CLK_S3D2),
-
-       DEF_MOD("i2c7",                 1003,   R8A774C0_CLK_S3D2),
-       DEF_MOD("ssi-all",              1005,   R8A774C0_CLK_S3D4),
-       DEF_MOD("ssi9",                 1006,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi8",                 1007,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi7",                 1008,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi6",                 1009,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi5",                 1010,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi4",                 1011,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi3",                 1012,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi2",                 1013,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi1",                 1014,   MOD_CLK_ID(1005)),
-       DEF_MOD("ssi0",                 1015,   MOD_CLK_ID(1005)),
-       DEF_MOD("scu-all",              1017,   R8A774C0_CLK_S3D4),
-       DEF_MOD("scu-dvc1",             1018,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-dvc0",             1019,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-ctu1-mix1",        1020,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-ctu0-mix0",        1021,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src9",             1022,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src8",             1023,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src7",             1024,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src6",             1025,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src5",             1026,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src4",             1027,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src3",             1028,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src2",             1029,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src1",             1030,   MOD_CLK_ID(1017)),
-       DEF_MOD("scu-src0",             1031,   MOD_CLK_ID(1017)),
+       DEF_MOD("dmaa_aclk",            111,    CLK_SEL_D,              RST_TYPEB,      1,      7,      4),
+#if 0
+       DEF_MOD("sdi0_aclk",            300,    CLK_SEL_D,              RST_NON,        0,      0,      0),
+       DEF_MOD("sdi0_imclk",           301,    CLK_SEL_SDI0,   RST_NON,        0,      0,      0),
+       DEF_MOD("sdi0_imclk2",          302,    CLK_SEL_SDI0,   RST_TYPEB,      3,      0,      6),
+       DEF_MOD("sdi0_clk_hs",          303,    CLK_PLL2_2,             RST_NON,        0,      0,      0),
+       DEF_MOD("emm_aclk",                     308,    CLK_SEL_D,              RST_NON,        0,      0,      0),
+       DEF_MOD("emm_imclk",            309,    CLK_SEL_SDI0,   RST_NON,        0,      0,      0),
+       DEF_MOD("emm_imclk2",           310,    CLK_SEL_SDI0,   RST_TYPEB,      3,      2,      7),
+       DEF_MOD("emm_clk_hs",           311,    CLK_PLL2_2,             RST_NON,        0,      0,      0),
+#endif
+       DEF_MOD("pci_aclk",                     400,    CLK_SEL_D,              RST_TYPEA,      3,      8,      0),
+       DEF_MOD("pci_clk_pmu",          401,    CLK_SEL_D,              RST_TYPEA,      3,      8,      0),
+       DEF_MOD("pci_apb_clk",          402,    CLK_SEL_E,              RST_NON,        0,      0,      0),
+       DEF_MOD("usb_aclk_h",           404,    CLK_SEL_D,              RST_TYPEA,      3,      10,     0),
+       DEF_MOD("usb_aclk_p",           405,    CLK_SEL_D,              RST_TYPEA,      3,      9,      0),
+       DEF_MOD("usb_pclk",                     406,    CLK_SEL_E,              RST_TYPEA,      3,      7,      0),
+       DEF_MOD("eth0_clk_axi",         408,    CLK_PLL2_8,             RST_TYPEB,      3,      11,     11),
+//     DEF_MOD("eth0_clk_chi",         408,    CLK_PLL2_16,    RST_TYPEB,      3,      11,     11),
+       DEF_MOD("eth0_clk_gptp_extern",409,             CLK_PLL2_16,RST_NON,    0,      0,      0,),
+       DEF_MOD("iic_pclk0",            912,    CLK_SEL_E,              RST_TYPEA,      6,      8,      0),
+       DEF_MOD("iic_pclk1",            1012,   CLK_SEL_E,              RST_TYPEA,      6,      9,      0),
+       DEF_MOD("tim_clk16",            1104,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk17",            1105,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk18",            1106,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk19",            1107,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk20",            1108,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk21",            1109,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk22",            1110,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk23",            1111,   CLK_MAIN_24,    RST_TYPEA,      6,      2,      0,),
+       DEF_MOD("tim_clk24",            1204,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk25",            1205,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk26",            1206,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk27",            1207,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk28",            1208,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk29",            1209,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk30",            1210,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("tim_clk31",            1211,   CLK_MAIN_24,    RST_TYPEA,      6,      3,      0,),
+       DEF_MOD("pwm_clk8",                     1404,   CLK_MAIN,               RST_TYPEB,      6,      5,      0,),
+       DEF_MOD("pwm_clk9",                     1405,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+       DEF_MOD("pwm_clk10",            1406,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+       DEF_MOD("pwm_clk11",            1407,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+       DEF_MOD("pwm_clk12",            1408,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+       DEF_MOD("pwm_clk13",            1409,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+       DEF_MOD("pwm_clk14",            1410,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+       DEF_MOD("pwm_clk15",            1411,   CLK_MAIN,               RST_TYPEB,      6,      5,      23),
+#if 0 //static defined is disabled
+       DEF_MOD("urt_pclk",                     1504,   CLK_SEL_E,              RST_TYPEB,      6,      10,     26),
+       DEF_MOD("urt_clk0",                     1505,   CLK_SEL_W0,             RST_NON,        0,      0,      0),
+       DEF_MOD("csi_clk0",                     1508,   CLK_SEL_CSI0,   RST_NON,        0,      0,      0),
+       DEF_MOD("csi_clk2",                     1510,   CLK_SEL_CSI2,   RST_NON,        0,      0,      0),
+#endif
+#if 0
+       DEF_MOD("drpa_aclk",            2000,   CLK_SEL_B,              RST_NON,        0,      0,      14),
+       DEF_MOD("drpa_dclk",            2001,   CLK_PLL6,               RST_NON,        0,      0,      0),
+       DEF_MOD("drpa_initclk",         2002,   CLK_MAIN,               RST_TYPEB,      9,      0,      0),
+#endif
 };
 
 static const unsigned int r8arzv2m_crit_mod_clks[] __initconst = {
-       MOD_CLK_ID(408),        /* INTC-AP (GIC) */
+//     MOD_CLK_ID(408),        /* INTC-AP (GIC) */
+       000
 };
 
 /*
@@ -266,19 +182,101 @@ static const struct rcar_gen3_cpg_pll_config cpg_pll_configs[2] __initconst = {
        { 1,            100,    3,       58,    3,      },
 };
 
-static int __init r8arzv2m_cpg_mssr_init(struct device *dev)
+int32_t r8arzv2m_cpg_setClockCtrl(void __iomem *base, uint8_t reg_num, uint16_t target, uint16_t set_value)
+{
+    void __iomem *offset = base + CPG_CLK_ON1;
+    uint32_t value;
+
+    if (reg_num < CPG_CLK_ON_REG_MIN || CPG_CLK_ON_REG_MAX < reg_num)
+{
+        return -EINVAL;
+    }
+
+    offset += ((reg_num - 1) * sizeof(uint32_t));
+
+    value = ((uint32_t)target << CPG_REG_WEN_SHIFT)
+            | (set_value & CPG_SET_DATA_MASK);
+
+    writel(value,offset);
+
+    return 0;
+}
+
+int32_t r8arzv2m_cpg_getClockCtrl(void __iomem *base, uint8_t reg_num, uint16_t target)
 {
-       const struct rcar_gen3_cpg_pll_config *cpg_pll_config;
-       u32 cpg_mode;
-       int error;
+    void __iomem *offset = base + CPG_CLK_ON1;
+    uint32_t value;
 
-       error = rcar_rst_read_mode_pins(&cpg_mode);
-       if (error)
-               return error;
+    if (reg_num < CPG_RST_REG_MIN || CPG_RST_REG_MAX < reg_num)
+    {
+        return 0xFFFFFFFF;
+    }
 
-       cpg_pll_config = &cpg_pll_configs[CPG_PLL_CONFIG_INDEX(cpg_mode)];
+    offset += ((reg_num - 1) * sizeof(uint32_t));
+
+       value = readl(offset);
+
+       value = value & target;
+    return value;
+}
 
-       return rcar_gen3_cpg_init(cpg_pll_config, 0, cpg_mode);
+int32_t CPG_SetResetCtrl(void __iomem *base, uint8_t reg_num, uint16_t target, uint16_t set_value)
+{
+    void __iomem *offset = base + CPG_RST1;
+    uint32_t value;
+
+    if (reg_num < CPG_RST_REG_MIN || CPG_RST_REG_MAX < reg_num)
+    {
+        return -EINVAL;
+    }
+
+    offset += ((reg_num - 1) * sizeof(uint32_t));
+
+    value = ((uint32_t)target << CPG_REG_WEN_SHIFT)
+            | (set_value & CPG_SET_DATA_MASK);
+
+    writel(value,offset);
+
+    return 0;
+}
+
+int32_t CPG_WaitResetMon(void __iomem *base, uint32_t timeout_c, uint32_t msk, uint32_t val)
+{
+    int32_t rslt = 0;
+    uint32_t count;
+
+       if (0 == msk)
+       {
+               rslt = 0;
+               return rslt;
+       }
+
+       count = timeout_c;
+       while (true)
+       {
+               if (val == (readl(base + CPG_RST_MON) & msk))
+               {
+                       rslt = 0;
+                       break;
+               }
+               if ((0 == timeout_c) || (0 < count))
+               {
+                       udelay(1);
+                       count--;
+               }
+               else
+               {
+                       rslt = -EBUSY;
+                       break;
+               }
+       }
+
+    return rslt;
+}
+
+static int __init r8arzv2m_cpg_mssr_init(struct device *dev)
+{
+       return 0;
 }
 
 const struct cpg_mssr_info r8arzv2m_cpg_mssr_info __initconst = {
@@ -291,7 +289,7 @@ const struct cpg_mssr_info r8arzv2m_cpg_mssr_info __initconst = {
        /* Module Clocks */
        .mod_clks = r8arzv2m_mod_clks,
        .num_mod_clks = ARRAY_SIZE(r8arzv2m_mod_clks),
-       .num_hw_mod_clks = 12 * 32,
+       .num_hw_mod_clks = ARRAY_SIZE(r8arzv2m_mod_clks),
 
        /* Critical Module Clocks */
        .crit_mod_clks = r8arzv2m_crit_mod_clks,
@@ -299,5 +297,5 @@ const struct cpg_mssr_info r8arzv2m_cpg_mssr_info __initconst = {
 
        /* Callbacks */
        .init = r8arzv2m_cpg_mssr_init,
-       .cpg_clk_register = rcar_gen3_cpg_clk_register,
+       //.cpg_clk_register = rcar_gen3_cpg_clk_register,
 };
diff --git a/drivers/clk/renesas/renesas-cpg-clkon.c b/drivers/clk/renesas/renesas-cpg-clkon.c
new file mode 100644
index 0000000..611a64a
--- /dev/null
+++ b/drivers/clk/renesas/renesas-cpg-clkon.c
@@ -0,0 +1,795 @@
+/*
+ * Renesas Clock Pulse Generator / Module Standby and Software Reset
+ *
+ * Copyright (C) 2015 Glider bvba
+ *
+ * Based on clk-mstp.c, clk-rcar-gen2.c, and clk-rcar-gen3.c
+ *
+ * Copyright (C) 2013 Ideas On Board SPRL
+ * Copyright (C) 2020 Renesas Electronics Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clk/renesas.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_clock.h>
+#include <linux/pm_domain.h>
+#include <linux/psci.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+
+#include <dt-bindings/clock/renesas-cpg-mssr.h>
+
+#include "renesas-cpg-clkon.h"
+#include "r9a09g011-cpg-mssr.h"
+#include "clk-div6.h"
+
+#ifdef DEBUG
+#define WARN_DEBUG(x)  WARN_ON(x)
+#else
+#define WARN_DEBUG(x)  do { } while (0)
+#endif
+
+static const u16 smstpcr[] = {
+};
+
+/**
+ * Clock Pulse Generator / Module Standby and Software Reset Private Data
+ *
+ * @rcdev: Optional reset controller entity
+ * @dev: CPG/MSSR device
+ * @base: CPG/MSSR register block base address
+ * @rmw_lock: protects RMW register accesses
+ * @clks: Array containing all Core and Module Clocks
+ * @num_core_clks: Number of Core Clocks in clks[]
+ * @num_mod_clks: Number of Module Clocks in clks[]
+ * @last_dt_core_clk: ID of the last Core Clock exported to DT
+ * @notifiers: Notifier chain to save/restore clock state for system resume
+ * @smstpcr_saved[].mask: Mask of SMSTPCR[] bits under our control
+ * @smstpcr_saved[].val: Saved values of SMSTPCR[]
+ */
+struct cpg_mssr_priv {
+#ifdef CONFIG_RESET_CONTROLLER
+       struct reset_controller_dev rcdev;
+#endif
+       struct device *dev;
+       void __iomem *base;
+       spinlock_t rmw_lock;
+
+       struct clk **clks;
+       unsigned int num_core_clks;
+       unsigned int num_mod_clks;
+       unsigned int last_dt_core_clk;
+
+       struct raw_notifier_head notifiers; //[TODO]
+       struct {
+               u32 mask;
+               u32 val;
+       } smstpcr_saved[ARRAY_SIZE(smstpcr)];
+       struct mssr_mod_clk *mod_clk;
+       struct cpg_core_clk *core_clk;
+
+};
+
+
+/**
+ * struct mstp_clock - MSTP gating clock
+ * @hw: handle between common and hardware-specific interfaces
+ * @index: MSTP clock number
+ * @priv: CPG/MSSR private data
+ */
+struct mstp_clock {
+       struct clk_hw hw;
+       u32 index;
+       u32 type;
+       u32 reset_no;
+       u32 reset_bit;
+       u32 reset_msk;
+       struct cpg_mssr_priv *priv;
+};
+
+#define to_mstp_clock(_hw) container_of(_hw, struct mstp_clock, hw)
+
+static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)
+{
+       struct mstp_clock *clock = to_mstp_clock(hw);
+       struct cpg_mssr_priv *priv = clock->priv;
+       unsigned int no = clock->index / 100;
+       unsigned int bit = clock->index % 100;
+       struct device *dev = priv->dev;
+       u32 bitmask = BIT(bit);
+       unsigned long flags;
+       unsigned int i;
+       u32 value;
+
+       dev_dbg(dev, "MSTP %u%02u/%pC %s\n", no, bit, hw->clk,
+               enable ? "ON" : "OFF");
+       spin_lock_irqsave(&priv->rmw_lock, flags);
+
+       if(clock->type == RST_TYPEA){
+               CPG_SetResetCtrl(priv->base,clock->reset_no,BIT(clock->reset_bit),0);
+               r8arzv2m_cpg_setClockCtrl(priv->base,no,BIT(bit),0);
+               udelay(1);
+               CPG_SetResetCtrl(priv->base,clock->reset_no,BIT(clock->reset_bit),BIT(clock->reset_bit));
+       }
+
+       if (enable)
+               value = bitmask;
+       else
+               value = 0;
+
+       r8arzv2m_cpg_setClockCtrl(priv->base,no,BIT(bit),value);
+
+       if(clock->type == RST_TYPEB){
+               CPG_SetResetCtrl(priv->base,clock->reset_no,BIT(clock->reset_bit),0);
+               CPG_SetResetCtrl(priv->base,clock->reset_no,BIT(clock->reset_bit),BIT(clock->reset_bit));
+               CPG_WaitResetMon(priv->base,100,clock->reset_msk,clock->reset_msk);
+       }
+
+       spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+       return 0;
+}
+
+static int cpg_mstp_clock_enable(struct clk_hw *hw)
+{
+       struct mstp_clock *clock = to_mstp_clock(hw);//add for debug
+       struct cpg_mssr_priv *priv = clock->priv;//add for debug
+
+       return cpg_mstp_clock_endisable(hw, true);
+}
+
+static void cpg_mstp_clock_disable(struct clk_hw *hw)
+{
+       struct mstp_clock *clock = to_mstp_clock(hw);//add for debug
+       struct cpg_mssr_priv *priv = clock->priv;//add for debug
+
+       cpg_mstp_clock_endisable(hw, false);
+}
+
+static int cpg_mstp_clock_is_enabled(struct clk_hw *hw)
+{
+       struct mstp_clock *clock = to_mstp_clock(hw);
+       struct cpg_mssr_priv *priv = clock->priv;
+       unsigned int no = clock->index / 100;
+       unsigned int bit = clock->index % 100;
+       u32 value;
+
+       value = r8arzv2m_cpg_getClockCtrl(priv->base,no,BIT(bit));
+
+       if(value == 0xFFFFFFFF){
+               return 0;
+       }
+
+       value = value >> bit;
+
+       return 0;//[TODO]return value;
+}
+
+static const struct clk_ops cpg_mstp_clock_ops = {
+       .enable = cpg_mstp_clock_enable,
+       .disable = cpg_mstp_clock_disable,
+       .is_enabled = cpg_mstp_clock_is_enabled,
+};
+
+static
+struct clk *cpg_mssr_clk_src_twocell_get(struct of_phandle_args *clkspec,
+                                        void *data)
+{
+       unsigned int clkidx = clkspec->args[1];
+       struct cpg_mssr_priv *priv = data;
+       struct device *dev = priv->dev;
+       unsigned int idx;
+       const char *type;
+       struct clk *clk;
+
+       switch (clkspec->args[0]) {
+       case CPG_CORE:
+               type = "core";
+               if (clkidx > priv->last_dt_core_clk) {
+                       dev_err(dev, "Invalid %s clock index %u\n", type,
+                              clkidx);
+                       return ERR_PTR(-EINVAL);
+               }
+               clk = priv->clks[clkidx];
+               break;
+
+       case CPG_MOD:
+               type = "module";
+               clk = priv->clks[priv->num_core_clks + clkidx];
+               break;
+
+       default:
+               dev_err(dev, "Invalid CPG clock type %u\n", clkspec->args[0]);
+               return ERR_PTR(-EINVAL);
+       }
+
+       if (IS_ERR(clk))
+               dev_err(dev, "Cannot get %s clock %u: %ld", type, clkidx,
+                      PTR_ERR(clk));
+       else
+               dev_dbg(dev, "clock (%u, %u) is %pC at %lu Hz\n",
+                       clkspec->args[0], clkspec->args[1], clk,
+                       clk_get_rate(clk));
+       return clk;
+}
+
+static void __init cpg_mssr_register_core_clk(const struct cpg_core_clk *core,
+                                             const struct cpg_mssr_info *info,
+                                             struct cpg_mssr_priv *priv)
+{
+       struct clk *clk = ERR_PTR(-ENOTSUPP), *parent;
+       struct device *dev = priv->dev;
+       unsigned int id = core->id, div = core->div;
+       const char *parent_name;
+       unsigned long t;
+       unsigned int i;
+
+       WARN_DEBUG(id >= priv->num_core_clks);
+       WARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);
+
+       if (!core->name) {
+               /* Skip NULLified clock */
+               return;
+       }
+
+       switch (core->type) {
+       case CLK_TYPE_FR:
+               clk = clk_register_fixed_rate(NULL, core->name, NULL, 0,
+                                             core->val);
+               break;
+
+       default:
+               parent = priv->clks[core->parent];
+               if (IS_ERR(parent)) {
+                       clk = parent;
+                       goto fail;
+               }
+
+               if(core->type == CLK_TYP_STATIC){
+                       for (i = 0; i < info->num_mod_clks; i++){
+                               if (core->id == info->mod_clks[i].parent) {
+                                       //children Cllock off
+                                       if(info->mod_clks[i].type == RST_TYPEA){
+                                               //Reset A reset
+                                               CPG_SetResetCtrl(priv->base,info->mod_clks[i].reset_no,
+                                                       BIT(info->mod_clks[i].reset_bit),0);
+                                       }
+                                       r8arzv2m_cpg_setClockCtrl(priv->base,
+                                       info->mod_clks[i].id/100 ,BIT(info->mod_clks[i].id%100),0);
+                               }
+                       }
+               }
+
+               if(core->type == CLK_TYPE_DIV){
+                       t = 0;
+                       while (10000000 > t++) //Time out in 1sec
+                       {
+                               if (0 == (readl(priv->base + CPG_CLKSTATUS) & core->status))
+                               {
+                                       break;
+                               }
+                               udelay(1);
+                       }
+               }
+               writel(core->msk | core->val, priv->base + core->offset);
+
+               if(core->type == CLK_TYPE_DIV){
+                       t = 0;
+                       while (10000000 > t++) //Time out in 1sec
+                       {
+                               if (0 == (readl(priv->base + CPG_CLKSTATUS) & core->status))
+                               {
+                                       break;
+                               }
+                               udelay(1);
+                       }
+               }
+
+               parent_name = __clk_get_name(parent);
+
+               clk = clk_register_fixed_factor(NULL, core->name,
+                                                       parent_name, 0, 1, div);
+
+               break;
+       }
+
+       if (IS_ERR_OR_NULL(clk))
+               goto fail;
+
+       dev_dbg(dev, "Core clock %pC at %lu Hz\n", clk, clk_get_rate(clk));
+       priv->clks[id] = clk;
+       return;
+
+fail:
+       dev_err(dev, "Failed to register %s clock %s: %ld\n", "core",
+               core->name, PTR_ERR(clk));
+}
+
+static void __init cpg_mssr_register_mod_clk(const struct mssr_mod_clk *mod,
+                                            const struct cpg_mssr_info *info,
+                                            struct cpg_mssr_priv *priv)
+{
+       struct mstp_clock *clock = NULL;
+       struct device *dev = priv->dev;
+       unsigned int id = mod->id;
+       struct clk_init_data init;
+       struct clk *parent, *clk;
+       const char *parent_name;
+       unsigned int i;
+
+       WARN_DEBUG(id < priv->num_core_clks);
+       WARN_DEBUG(id >= priv->num_core_clks + priv->num_mod_clks);
+       WARN_DEBUG(mod->parent >= priv->num_core_clks + priv->num_mod_clks);
+       WARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);
+
+       if (!mod->name) {
+               /* Skip NULLified clock */
+               return;
+       }
+
+       parent = priv->clks[mod->parent];
+       if (IS_ERR(parent)) {
+               clk = parent;
+               goto fail;
+       }
+
+       clock = kzalloc(sizeof(*clock), GFP_KERNEL);
+       if (!clock) {
+               clk = ERR_PTR(-ENOMEM);
+               goto fail;
+       }
+
+       init.name = mod->name;
+       init.ops = &cpg_mstp_clock_ops;
+       init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+       for (i = 0; i < info->num_crit_mod_clks; i++)
+               if (id == info->crit_mod_clks[i]) {
+                       dev_dbg(dev, "MSTP %s setting CLK_IS_CRITICAL\n",
+                               mod->name);
+                       init.flags |= CLK_IS_CRITICAL;
+                       break;
+               }
+
+       parent_name = __clk_get_name(parent);
+       init.parent_names = &parent_name;
+       init.num_parents = 1;
+
+       clock->index = id - priv->num_core_clks;
+       clock->priv = priv;
+       clock->hw.init = &init;
+
+       clk = clk_register(NULL, &clock->hw);
+       if (IS_ERR(clk))
+               goto fail;
+
+       dev_dbg(dev, "Module clock %pC at %lu Hz\n", clk, clk_get_rate(clk));
+       priv->clks[id] = clk;
+       priv->smstpcr_saved[clock->index / 100].mask |= BIT(clock->index % 100); //[TODO:saved module stop manage]
+       return;
+
+fail:
+       dev_err(dev, "Failed to register %s clock %s: %ld\n", "module",
+               mod->name, PTR_ERR(clk));
+       kfree(clock);
+}
+
+struct cpg_mssr_clk_domain {
+       struct generic_pm_domain genpd;
+       struct device_node *np;
+       unsigned int num_core_pm_clks;
+       unsigned int core_pm_clks[0];
+};
+
+static struct cpg_mssr_clk_domain *cpg_mssr_clk_domain;
+
+static bool cpg_mssr_is_pm_clk(const struct of_phandle_args *clkspec,
+                              struct cpg_mssr_clk_domain *pd)
+{
+       unsigned int i;
+
+       if (clkspec->np != pd->np || clkspec->args_count != 2)
+               return false;
+
+       switch (clkspec->args[0]) {
+       case CPG_CORE:
+               for (i = 0; i < pd->num_core_pm_clks; i++)
+                       if (clkspec->args[1] == pd->core_pm_clks[i])
+                               return true;
+               return false;
+
+       case CPG_MOD:
+               return true;
+
+       default:
+               return false;
+       }
+}
+
+int cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev)
+{
+       struct cpg_mssr_clk_domain *pd = cpg_mssr_clk_domain;
+       struct device_node *np = dev->of_node;
+       struct of_phandle_args clkspec;
+       struct clk *clk;
+       int i = 0;
+       int error;
+
+       if (!pd) {
+               dev_dbg(dev, "CPG/MSSR clock domain not yet available\n");
+               return -EPROBE_DEFER;
+       }
+
+       while (!of_parse_phandle_with_args(np, "clocks", "#clock-cells", i,
+                                          &clkspec)) {
+               if (cpg_mssr_is_pm_clk(&clkspec, pd))
+                       goto found;
+
+               of_node_put(clkspec.np);
+               i++;
+       }
+
+       return 0;
+
+found:
+       clk = of_clk_get_from_provider(&clkspec);
+       of_node_put(clkspec.np);
+
+       if (IS_ERR(clk))
+               return PTR_ERR(clk);
+
+       error = pm_clk_create(dev);
+       if (error) {
+               dev_err(dev, "pm_clk_create failed %d\n", error);
+               goto fail_put;
+       }
+
+       error = pm_clk_add_clk(dev, clk);
+       if (error) {
+               dev_err(dev, "pm_clk_add_clk %pC failed %d\n", clk, error);
+               goto fail_destroy;
+       }
+
+       return 0;
+
+fail_destroy:
+       pm_clk_destroy(dev);
+fail_put:
+       clk_put(clk);
+       return error;
+}
+
+void cpg_mssr_detach_dev(struct generic_pm_domain *unused, struct device *dev)
+{
+       if (!pm_clk_no_clocks(dev))
+               pm_clk_destroy(dev);
+}
+
+static int __init cpg_mssr_add_clk_domain(struct device *dev,
+                                         const unsigned int *core_pm_clks,
+                                         unsigned int num_core_pm_clks)
+{
+       struct device_node *np = dev->of_node;
+       struct generic_pm_domain *genpd;
+       struct cpg_mssr_clk_domain *pd;
+       size_t pm_size = num_core_pm_clks * sizeof(core_pm_clks[0]);
+
+       pd = devm_kzalloc(dev, sizeof(*pd) + pm_size, GFP_KERNEL);
+       if (!pd)
+               return -ENOMEM;
+
+       pd->np = np;
+       pd->num_core_pm_clks = num_core_pm_clks;
+       memcpy(pd->core_pm_clks, core_pm_clks, pm_size);
+
+       genpd = &pd->genpd;
+       genpd->name = np->name;
+       genpd->flags = GENPD_FLAG_PM_CLK | GENPD_FLAG_ACTIVE_WAKEUP;
+       genpd->attach_dev = cpg_mssr_attach_dev;
+       genpd->detach_dev = cpg_mssr_detach_dev;
+       pm_genpd_init(genpd, &pm_domain_always_on_gov, false);
+       cpg_mssr_clk_domain = pd;
+
+       of_genpd_add_provider_simple(np, genpd);
+       return 0;
+}
+
+#ifdef CONFIG_RESET_CONTROLLER
+
+#define rcdev_to_priv(x)       container_of(x, struct cpg_mssr_priv, rcdev)
+
+static int cpg_mssr_reset(struct reset_controller_dev *rcdev,
+                         unsigned long id)
+{
+       struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+       unsigned int reg = id / 100;
+       unsigned int bit = id % 100;
+       u32 bitmask = BIT(bit);
+       unsigned long flags;
+       u32 value;
+       u32 idx;
+
+       /* Reset module */
+       spin_lock_irqsave(&priv->rmw_lock, flags);
+
+
+       for( idx = 0; idx < priv->num_mod_clks; idx++ )
+       {
+               if((priv->mod_clk[idx].reset_no == reg) && (priv->mod_clk[idx].reset_bit == bit) )
+               {
+                       dev_info(NULL, "deassert reset[%u] bit[%02u]\n", priv->mod_clk[idx].reset_no, priv->mod_clk[idx].reset_bit);
+                       break;
+
+               }
+       }
+
+       if(priv->mod_clk->type == RST_TYPEA){
+               dev_info(priv->dev,"Not support type A Reset.\n");
+       }
+
+       if(priv->mod_clk->type == RST_TYPEB){
+               CPG_SetResetCtrl(priv->base,reg,BIT(bit),0);
+               CPG_SetResetCtrl(priv->base,reg,BIT(bit),BIT(bit));
+               CPG_WaitResetMon(priv->base,100,priv->mod_clk[idx].reset_msk,priv->mod_clk[idx].reset_msk);
+       }
+
+       spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+       return 0;
+}
+
+static int cpg_mssr_assert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+       struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+       unsigned int reg = id / 100;
+       unsigned int bit = id % 100;
+       u32 bitmask = BIT(bit);
+       unsigned long flags;
+       u32 value;
+       u32 idx;
+
+       dev_dbg(priv->dev, "reset %u%02u\n", reg, bit);
+
+       /* Reset module */
+       spin_lock_irqsave(&priv->rmw_lock, flags);
+
+
+       for( idx = 0; idx < priv->num_mod_clks; idx++ )
+       {
+               if((priv->mod_clk[idx].reset_no == reg) && (priv->mod_clk[idx].reset_bit == bit) )
+               {
+                       dev_dbg(NULL, "deassert reset[%u] bit[%02u]\n", priv->mod_clk[idx].reset_no, priv->mod_clk[idx].reset_bit);
+                       break;
+
+               }
+       }
+
+       if(priv->mod_clk->type == RST_TYPEA){
+               dev_info(priv->dev,"Not support type A Reset.\n");//[DEBUG]
+       }
+
+       if(priv->mod_clk->type == RST_TYPEB){
+               //CPG_SetResetCtrl(priv->base,reg,BIT(bit),0);
+               CPG_SetResetCtrl(priv->base,reg,BIT(bit),BIT(bit));
+               CPG_WaitResetMon(priv->base,100,priv->mod_clk[idx].reset_msk,priv->mod_clk[idx].reset_msk);
+       }
+
+       spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+       return 0;
+}
+
+static int cpg_mssr_deassert(struct reset_controller_dev *rcdev,
+                            unsigned long id)
+{
+       struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+       unsigned int reg = id / 100;
+       unsigned int bit = id % 100;
+       u32 bitmask = BIT(bit);
+       unsigned long flags;
+       u32 value;
+       u32 idx;
+
+       dev_dbg(priv->dev, "reset %u%02u\n", reg, bit);
+
+       /* Reset module */
+       spin_lock_irqsave(&priv->rmw_lock, flags);
+
+
+       for( idx = 0; idx < priv->num_mod_clks; idx++ )
+       {
+               if((priv->mod_clk[idx].reset_no == reg) && (priv->mod_clk[idx].reset_bit == bit) )
+               {
+                       dev_dbg(NULL, "deassert reset[%u] bit[%02u]\n", priv->mod_clk[idx].reset_no, priv->mod_clk[idx].reset_bit);
+                       break;
+
+               }
+       }
+
+       if(priv->mod_clk->type == RST_TYPEA){
+               dev_info(priv->dev,"Not support type A Reset.\n");//[DEBUG]
+       }
+
+       if(priv->mod_clk->type == RST_TYPEB){
+               CPG_SetResetCtrl(priv->base,reg,BIT(bit),0);
+               CPG_WaitResetMon(priv->base,100,priv->mod_clk[idx].reset_msk,0);
+       }
+
+       spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+       return 0;
+}
+
+static int cpg_mssr_status(struct reset_controller_dev *rcdev,
+                          unsigned long id)
+{
+       struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+       unsigned int reg = id / 32;
+       unsigned int bit = id % 32;
+       u32 bitmask = BIT(bit);
+
+       dev_dbg(priv->dev, "status %u%02u\n", reg, bit);
+
+       return 0;
+}
+
+static const struct reset_control_ops cpg_mssr_reset_ops = {
+       .reset = cpg_mssr_reset,
+       .assert = cpg_mssr_assert,
+       .deassert = cpg_mssr_deassert,
+       .status = cpg_mssr_status,
+};
+
+static int cpg_mssr_reset_xlate(struct reset_controller_dev *rcdev,
+                               const struct of_phandle_args *reset_spec)
+{
+       struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+       unsigned int unpacked = reset_spec->args[0];
+       unsigned int idx = unpacked;//MOD_CLK_PACK(unpacked);
+
+       if (unpacked % 100 > 31 || idx >= rcdev->nr_resets) {
+               dev_err(priv->dev, "Invalid reset index %u\n", unpacked);
+               return -EINVAL;
+       }
+
+       return idx;
+}
+
+static int cpg_mssr_reset_controller_register(struct cpg_mssr_priv *priv)
+{
+       priv->rcdev.ops = &cpg_mssr_reset_ops;
+       priv->rcdev.of_node = priv->dev->of_node;
+       priv->rcdev.of_reset_n_cells = 1;
+       priv->rcdev.of_xlate = cpg_mssr_reset_xlate;
+       priv->rcdev.nr_resets = priv->num_mod_clks;
+       return devm_reset_controller_register(priv->dev, &priv->rcdev);
+}
+
+#else /* !CONFIG_RESET_CONTROLLER */
+static inline int cpg_mssr_reset_controller_register(struct cpg_mssr_priv *priv)
+{
+       return 0;
+}
+#endif /* !CONFIG_RESET_CONTROLLER */
+
+
+static const struct of_device_id cpg_mssr_match[] = {
+#ifdef CONFIG_CLK_R9A09G011GBG
+       {
+               .compatible = "renesas,r8arzv2m-cpg-mssr",
+               .data = &r8arzv2m_cpg_mssr_info,
+       },
+#endif
+       { /* sentinel */ }
+};
+
+static void cpg_mssr_del_clk_provider(void *data)
+{
+       of_clk_del_provider(data);
+}
+
+static int __init cpg_mssr_probe(struct platform_device *pdev)
+{
+       struct device *dev = &pdev->dev;
+       struct device_node *np = dev->of_node;
+       const struct cpg_mssr_info *info;
+       struct cpg_mssr_priv *priv;
+       unsigned int nclks, i;
+       struct resource *res;
+       struct clk **clks;
+       int error;
+
+       info = of_device_get_match_data(dev);
+       if (info->init) {
+               error = info->init(dev);
+               if (error)
+                       return error;
+       }
+
+       priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+       if (!priv)
+               return -ENOMEM;
+
+       priv->dev = dev;
+       spin_lock_init(&priv->rmw_lock);
+
+       res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+       priv->base = devm_ioremap_resource(dev, res);
+       if (IS_ERR(priv->base))
+               return PTR_ERR(priv->base);
+
+//     nclks = info->num_total_core_clks + info->num_hw_mod_clks;
+       nclks = 20*1000;//[TODO]:Need to adujst the table size.
+       clks = devm_kmalloc_array(dev, nclks, sizeof(*clks), GFP_KERNEL);
+       if (!clks)
+               return -ENOMEM;
+
+       dev_set_drvdata(dev, priv);
+       priv->clks = clks;
+       priv->num_core_clks = info->num_total_core_clks;
+       priv->num_mod_clks = info->num_hw_mod_clks;
+       priv->last_dt_core_clk = info->last_dt_core_clk;
+       priv->mod_clk = info->mod_clks;
+       priv->core_clk = info->core_clks;
+       RAW_INIT_NOTIFIER_HEAD(&priv->notifiers);
+
+       for (i = 0; i < nclks; i++)
+               clks[i] = ERR_PTR(-ENOENT);
+
+       for (i = 0; i < info->num_core_clks; i++)
+               cpg_mssr_register_core_clk(&info->core_clks[i], info, priv);
+
+       for (i = 0; i < info->num_mod_clks; i++)
+               cpg_mssr_register_mod_clk(&info->mod_clks[i], info, priv);
+
+       error = of_clk_add_provider(np, cpg_mssr_clk_src_twocell_get, priv);
+       if (error)
+               return error;
+
+       error = devm_add_action_or_reset(dev,
+                                        cpg_mssr_del_clk_provider,
+                                        np);
+       if (error)
+               return error;
+
+       error = cpg_mssr_add_clk_domain(dev, info->core_pm_clks,
+                                       info->num_core_pm_clks);
+       if (error)
+               return error;
+
+       error = cpg_mssr_reset_controller_register(priv);
+       if (error)
+               return error;
+
+       return 0;
+}
+
+static struct platform_driver cpg_mssr_driver = {
+       .driver         = {
+               .name   = "renesas-cpg-mssr",
+               .of_match_table = cpg_mssr_match,
+
+       },
+};
+
+static int __init cpg_mssr_init(void)
+{
+       return platform_driver_probe(&cpg_mssr_driver, cpg_mssr_probe);
+}
+
+subsys_initcall(cpg_mssr_init);
+
+MODULE_DESCRIPTION("Renesas CPG/CLKON Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/renesas/renesas-cpg-clkon.h b/drivers/clk/renesas/renesas-cpg-clkon.h
new file mode 100644
index 0000000..fe64ec2
--- /dev/null
+++ b/drivers/clk/renesas/renesas-cpg-clkon.h
@@ -0,0 +1,194 @@
+/*
+ * Renesas Clock Pulse Generator / Module Standby and Software Reset
+ *
+ * Copyright (C) 2015 Glider bvba
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+#ifndef __CLK_RENESAS_CPG_MSSR_H__
+#define __CLK_RENESAS_CPG_MSSR_H__
+
+    /*
+     * Definitions of CPG Core Clocks
+     *
+     * These include:
+     *   - Clock outputs exported to DT
+     *   - External input clocks
+     *   - Internal CPG clocks
+     */
+
+struct cpg_core_clk {
+       /* Common */
+       const char *name;
+       unsigned int id;
+       unsigned int parent;
+       unsigned int offset;
+       unsigned int div;
+       unsigned int msk;
+       unsigned long val;
+       unsigned int status;
+       unsigned int type;
+};
+
+enum clk_types {
+       /* Generic */
+       CLK_TYPE_IN,            /* External Clock Input */
+       CLK_TYPE_FF,            /* Fixed Factor Clock */
+       CLK_TYPE_FR,            /* Fixed Rate Clock */
+
+       /* Custom definitions start here */
+       CLK_TYP_STATIC,
+       CLK_TYPE_DIV,           /* Fixed Rate Clock */
+       CLK_TYPE_CUSTOM,
+};
+
+enum rst_types {
+       RST_NON,
+       RST_TYPEA,
+       RST_TYPEB,
+};
+
+#define DEF_TYPE(_name, _id, _type...) \
+       { .name = _name, .id = _id, .type = _type }
+#define DEF_BASE(_name, _id, _type, _parent...)        \
+       DEF_TYPE(_name, _id, _type, .parent = _parent)
+#define DEF_INPUT(_name, _id) \
+       DEF_TYPE(_name, _id, CLK_TYPE_IN)
+#define DEF_FIXED(_name, _id, _parent, _div, _mult)    \
+       DEF_BASE(_name, _id, CLK_TYPE_FF, _parent, .div = _div, .val = _mult)
+#define DEF_STATIC(_name, _id, _parent, _div, _offset, _msk, _mult)    \
+       DEF_BASE(_name, _id, CLK_TYP_STATIC, _parent,.div = _div, .offset=_offset, .msk=_msk, .val = _mult)
+#define DEF_DIV(_name, _id, _parent, _div, _offset, _msk, _status, _mult)      \
+       DEF_BASE(_name, _id, CLK_TYPE_DIV, _parent, .div = _div, .offset=_offset, .msk=_msk, .status=_status, .val = _mult)
+#define DEF_DIV6P1(_name, _id, _parent, _offset)       \
+       DEF_BASE(_name, _id, CLK_TYPE_DIV6P1, _parent, .offset = _offset)
+#define DEF_DIV6_RO(_name, _id, _parent, _offset, _div)        \
+       DEF_BASE(_name, _id, CLK_TYPE_DIV6_RO, _parent, .offset = _offset, .div = _div, .mult = 1)
+#define DEF_RATE(_name, _id, _rate)    \
+       DEF_TYPE(_name, _id, CLK_TYPE_FR, .val=_rate)
+
+    /*
+     * Definitions of Module Clocks
+     */
+
+struct mssr_mod_clk {
+       const char *name;
+       unsigned int id;
+       unsigned int parent;    /* Add MOD_CLK_BASE for Module Clocks */
+       unsigned int type;
+       unsigned int reset_no;
+       unsigned int reset_bit;
+       unsigned int reset_msk;
+};
+
+/* Convert from sparse base-100 to packed index space */
+//#define MOD_CLK_PACK(x)      ((x) - ((x) / 100) * (100 - 32))
+
+#define MOD_CLK_ID(x)  (MOD_CLK_BASE + (x))
+
+// #define DEF_MOD(_name, _mod, _parent...)    \
+//     { .name = _name, .id = MOD_CLK_ID(_mod), .parent = _parent }
+#define DEF_MOD(_name, _mod, _parent, _type, _reset_no, _reset_bit, _reset_msk...)     \
+       { .name = _name, .id = MOD_CLK_ID(_mod), .parent = _parent,  \
+       .type=_type, .reset_no=_reset_no, .reset_bit=_reset_bit, .reset_msk=_reset_msk}
+
+
+struct device_node;
+
+    /**
+     * SoC-specific CPG/MSSR Description
+     *
+     * @core_clks: Array of Core Clock definitions
+     * @num_core_clks: Number of entries in core_clks[]
+     * @last_dt_core_clk: ID of the last Core Clock exported to DT
+     * @num_total_core_clks: Total number of Core Clocks (exported + internal)
+     *
+     * @mod_clks: Array of Module Clock definitions
+     * @num_mod_clks: Number of entries in mod_clks[]
+     * @num_hw_mod_clks: Number of Module Clocks supported by the hardware
+     *
+     * @crit_mod_clks: Array with Module Clock IDs of critical clocks that
+     *                 should not be disabled without a knowledgeable driver
+     * @num_crit_mod_clks: Number of entries in crit_mod_clks[]
+     *
+     * @core_pm_clks: Array with IDs of Core Clocks that are suitable for Power
+     *                Management, in addition to Module Clocks
+     * @num_core_pm_clks: Number of entries in core_pm_clks[]
+     *
+     * @init: Optional callback to perform SoC-specific initialization
+     * @cpg_clk_register: Optional callback to handle special Core Clock types
+     */
+
+struct cpg_mssr_info {
+       /* Core Clocks */
+       const struct cpg_core_clk *core_clks;
+       unsigned int num_core_clks;
+       unsigned int last_dt_core_clk;
+       unsigned int num_total_core_clks;
+
+       /* Module Clocks */
+       const struct mssr_mod_clk *mod_clks;
+       unsigned int num_mod_clks;
+       unsigned int num_hw_mod_clks;
+
+       /* Critical Module Clocks that should not be disabled */
+       const unsigned int *crit_mod_clks;
+       unsigned int num_crit_mod_clks;
+
+       /* Core Clocks suitable for PM, in addition to the Module Clocks */
+       const unsigned int *core_pm_clks;
+       unsigned int num_core_pm_clks;
+
+       /* Callbacks */
+       int (*init)(struct device *dev);
+       struct clk *(*cpg_clk_register)(struct device *dev,
+                                       const struct cpg_core_clk *core,
+                                       const struct cpg_mssr_info *info,
+                                       struct clk **clks, void __iomem *base,
+                                       struct raw_notifier_head *notifiers);
+};
+
+extern const struct cpg_mssr_info r8a7743_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7745_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a77470_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a774a1_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a774b1_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a774c0_cpg_mssr_info;
+extern const struct cpg_mssr_info r8arzv2m_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7790_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7791_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7792_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7794_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7795_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a7796_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a77965_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a77970_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a77980_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a77990_cpg_mssr_info;
+extern const struct cpg_mssr_info r8a77995_cpg_mssr_info;
+
+
+    /*
+     * Helpers for fixing up clock tables depending on SoC revision
+     */
+
+struct mssr_mod_reparent {
+       unsigned int clk, parent;
+};
+
+
+extern void cpg_core_nullify_range(struct cpg_core_clk *core_clks,
+                                  unsigned int num_core_clks,
+                                  unsigned int first_clk,
+                                  unsigned int last_clk);
+extern void mssr_mod_nullify(struct mssr_mod_clk *mod_clks,
+                            unsigned int num_mod_clks,
+                            const unsigned int *clks, unsigned int n);
+extern void mssr_mod_reparent(struct mssr_mod_clk *mod_clks,
+                             unsigned int num_mod_clks,
+                             const struct mssr_mod_reparent *clks,
+                             unsigned int n);
+#endif
diff --git a/include/linux/clk/renesas.h b/include/linux/clk/renesas.h
index 9ebf1f8..e13ef51 100644
--- a/include/linux/clk/renesas.h
+++ b/include/linux/clk/renesas.h
@@ -33,7 +33,13 @@ void cpg_mstp_detach_dev(struct generic_pm_domain *unused, struct device *dev);
 int cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev);
 void cpg_mssr_detach_dev(struct generic_pm_domain *unused, struct device *dev);
 #else
-#define cpg_mssr_attach_dev	NULL
-#define cpg_mssr_detach_dev	NULL
+//#define cpg_mssr_attach_dev  NULL
+//#define cpg_mssr_detach_dev  NULL
 #endif
+
+#ifdef CONFIG_CLK_RENESAS_CPG_CLKON
+int cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev);
+void cpg_mssr_detach_dev(struct generic_pm_domain *unused, struct device *dev);
+#endif
+
 #endif
-- 
2.7.4

