diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
index 224b908..23bc7ac 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
@@ -195,3 +195,36 @@
 	};
 };
 #endif
+
+&pwm0 {
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&pwm2 {
+	status = "okay";
+};
+
+&pwm3 {
+	status = "okay";
+};
+
+&pwm4 {
+	status = "okay";
+};
+
+&pwm5 {
+	status = "okay";
+};
+
+&pwm6 {
+	status = "okay";
+};
+
+&pwm7 {
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
index 9fd1477..61744bb 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
@@ -156,7 +156,21 @@
 		compatible = "fixed-clock";
 		clock-frequency = <200000000>;
 	};
-
+	sys: sys@100M {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <100000000>;
+	};
+	pwm: pwm@48M {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <48000000>;
+	};
+	csi_clk: wdt_clk: pclk48: clk@48M {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <48000000>;
+	};
 
 #endif
 
@@ -411,6 +425,181 @@
 				/*interrupts = <21 IRQ_TYPE_LEVEL_LOW>;*/
 			};
 		};
+		pwm0: pwm@a4010000 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010000 0 0x80>;
+			interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm1: pwm@a4010080 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010080 0 0x80>;
+			interrupts = <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm2: pwm@a4010100 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010100 0 0x80>;
+			interrupts = <GIC_SPI 370 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm3: pwm@a4010180 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010180 0 0x80>;
+			interrupts = <GIC_SPI 371 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm4: pwm@a4010200 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010200 0 0x80>;
+			interrupts = <GIC_SPI 372 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm5: pwm@a4010280 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010280 0 0x80>;
+			interrupts = <GIC_SPI 373 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm6: pwm@a4010300 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010300 0 0x80>;
+			interrupts = <GIC_SPI 374 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm7: pwm@a4010380 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010380 0 0x80>;
+			interrupts = <GIC_SPI 375 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm8: pwm@a4010400 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010400 0 0x80>;
+			interrupts = <GIC_SPI 376 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm9: pwm@a4010480 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010480 0 0x80>;
+			interrupts = <GIC_SPI 377 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm10: pwm@a4010500 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010500 0 0x80>;
+			interrupts = <GIC_SPI 378 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm11: pwm@a4010580 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010580 0 0x80>;
+			interrupts = <GIC_SPI 379 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm12: pwm@a4010600 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010600 0 0x80>;
+			interrupts = <GIC_SPI 380 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm13: pwm@a4010680 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010680 0 0x80>;
+			interrupts = <GIC_SPI 381 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm14: pwm@a4010700 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010700 0 0x80>;
+			interrupts = <GIC_SPI 382 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
+
+		pwm15: pwm@a4010780 {
+			compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
+			reg = <0 0xa4010780 0 0x80>;
+			interrupts = <GIC_SPI 383 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sys>, <&pwm>;
+			clock-names = "sys", "pwm";
+			/*power-domains = <&sysc R8A774C0_PD_ALWAYS_ON>;*/
+			#pwm-cells = <2>;
+			status = "disabled";
+		};
 #endif
 	};
 
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index b00e50f..f15de77 100755
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -392,3 +392,4 @@ CONFIG_E1000E=y
 CONFIG_U_DMA_BUF=y
 #CONFIG_PHYLIB=y
 #CONFIG_MDIO_DEVICE=y
+CONFIG_PWM_RZV2M=y
\ No newline at end of file
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 504d252..06cc890 100755
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -362,6 +362,18 @@ config PWM_RENESAS_TPU
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-renesas-tpu.
 
+config PWM_RZV2M
+	tristate "Renesas RZV2M PWM support"
+	depends on ARCH_RENESAS || COMPILE_TEST
+	depends on HAS_IOMEM
+	help
+	  This driver exposes the PWM controller found in Renesas
+	  RZV2M chips through the PWM API.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-v2m.
+
+
 config PWM_ROCKCHIP
 	tristate "Rockchip PWM support"
 	depends on ARCH_ROCKCHIP
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 9c676a0..5d74c6a 100755
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -51,3 +51,4 @@ obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
 obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
 obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
 obj-$(CONFIG_PWM_ZX)		+= pwm-zx.o
+obj-$(CONFIG_PWM_RZV2M)		+= pwm-v2m.o
diff --git b/drivers/pwm/pwm-v2m.c b/drivers/pwm/pwm-v2m.c
new file mode 100755
index 0000000..4875981
--- /dev/null
+++ b/drivers/pwm/pwm-v2m.c
@@ -0,0 +1,423 @@
+/*
+ * V2M PWM Timer driver
+ *
+ * Copyright (C) 2020 Renesas Electronics Corporation
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#define V2M_PWMCTR					0x00			//PWM control register
+#define V2M_PWMCTR_PWMPS_MASK		0x00030000		//bit mask of PWMPS bit
+#define V2M_PWMCTR_PWMPS_SHIFT		16				//bit shift of PWMPS bit
+#define V2M_PWMCTR_PWMHL			BIT(3)			//PWM signal output level setting
+#define V2M_PWMCTR_PWMTM			BIT(2)
+#define V2M_PWMCTR_PWME				BIT(1)
+#define V2M_PWMCTR_PWMS				BIT(0)
+
+#define V2M_PWMCYC					0x04			//PWM cycle setting register
+#define V2M_PWMCYC_MASK				0x00ffffff
+#define V2M_PWMCYC_SHIFT			0
+
+#define V2M_PWMLOW					0x08			//PWM low width setting register
+#define V2M_PWMLOW_MASK				0x00ffffff
+#define V2M_PWMLOW_SHIFT			0
+
+#define V2M_PWMCNT					0x0C			//PWM counter register
+#define V2M_PWMCNT_MASK				0x00ffffff
+#define V2M_PWMCNT_SHIFT			0
+
+#define V2M_PWMIEN					0x10			//PWM interrupt enable register
+#define V2M_PWMIEN_PWMER			BIT(2)			//Enable interrupt output at PWM rising edge
+#define V2M_PWMIEN_PWMEF			BIT(1)			//Enable interrupt output at PWM falling edge
+#define V2M_PWMIEN_PWMEC			BIT(0)			//Enable interrupt by clear counter
+
+#define V2M_PWMINT					0x14			//PWM interrupt register
+#define V2M_PWMINT_PWMIR			BIT(2)			//The interrupt generated at the rising edge of PWM can be monitored
+#define V2M_PWMINT_PWMIF			BIT(1)			//The interrupt generated at the falling edge of PWM can be monitored
+#define V2M_PWMINT_PWMIC			BIT(0)			//The interrupt generated by clear counter of PWM can be monitored, this interrupt use for choose PWM running mode (single cycle or continuous)
+
+#define MAX_PWMCYS				  16777215 /* Max value of 24 bits register is ffffff */
+
+int division[4] = {1, 16, 256, 2048};
+
+struct v2m_pwm_chip {
+	struct pwm_chip chip;
+	void __iomem *base;
+	struct clk *sys_clk;
+	struct clk *pwm_clk;
+};
+
+static void wait_time(struct v2m_pwm_chip *rp, int num_sys_clk, int num_pwm_clk)
+{
+	unsigned long pwm_clk_rate = clk_get_rate(rp->pwm_clk);
+	unsigned long sys_clk_rate = clk_get_rate(rp->sys_clk);
+
+	unsigned long long pwm_one_cycle, sys_one_cycle;	/* nanoseconds */
+
+	pwm_one_cycle = (unsigned long long)NSEC_PER_SEC;
+	do_div(pwm_one_cycle, pwm_clk_rate);
+	sys_one_cycle = (unsigned long long)NSEC_PER_SEC;
+	do_div(sys_one_cycle, sys_clk_rate);
+
+	ndelay(num_sys_clk * sys_one_cycle + num_pwm_clk * pwm_one_cycle);
+}
+
+static inline struct v2m_pwm_chip *to_v2m_pwm_chip(struct pwm_chip *chip)
+{
+	return container_of(chip, struct v2m_pwm_chip, chip);
+}
+
+static void v2m_pwm_write(struct v2m_pwm_chip *rp, u32 data,
+				unsigned int offset)
+{
+	writel(data, rp->base + offset);
+}
+
+static u32 v2m_pwm_read(struct v2m_pwm_chip *rp, unsigned int offset)
+{
+	return readl(rp->base + offset);
+}
+
+static void v2m_pwm_update(struct v2m_pwm_chip *rp, u32 mask, u32 data,
+				unsigned int offset)
+{
+	u32 value;
+
+	value = v2m_pwm_read(rp, offset);
+	value &= ~mask;
+	value |= data & mask;
+	v2m_pwm_write(rp, value, offset);
+}
+
+static int v2m_pwm_get_clock_division(struct v2m_pwm_chip *rp, int period_ns)
+{
+	unsigned long pwm_clk_rate = clk_get_rate(rp->pwm_clk); /* Hz */
+	unsigned int i, div;
+	u32 set_div,set_div_data;
+	unsigned long long one_cycle;	/* nanoseconds */
+
+	if (pwm_clk_rate == 0)
+		return -EINVAL;
+
+	one_cycle = (unsigned long long)NSEC_PER_SEC;
+	do_div(one_cycle, pwm_clk_rate);
+
+	for (i = 0; i < 4; i++) {
+		div = division[i];
+		if (div >= period_ns/((MAX_PWMCYS+1) * one_cycle))
+			break;
+		else if (i == 3)
+			return -EINVAL;
+	}
+
+	switch (i)
+	{
+		case 0:
+			set_div = 0x0;
+			break;
+		case 1:
+			set_div = 0x1;
+			break;
+		case 2:
+			set_div = 0x2;
+			break;
+		case 3:
+			set_div = 0x3;
+			break;
+		default:
+			set_div = 0x0;
+			break;
+	}
+	
+	set_div_data = set_div << V2M_PWMCTR_PWMPS_SHIFT;
+
+	v2m_pwm_update(rp, V2M_PWMCTR_PWMPS_MASK, set_div_data, V2M_PWMCTR);
+	wait_time(rp, 6, 9); //leave a write interval of 6 * PCLK + 9 * PWM_CLK
+
+	return div;
+}
+
+static int v2m_pwm_set_counter(struct v2m_pwm_chip *rp, int div, int duty_ns,
+				int period_ns)
+{
+	unsigned long long one_cycle, tmp, tmp2, tmp3;	/* picoseconds */
+	unsigned long pwm_clk_rate = clk_get_rate(rp->pwm_clk);
+	u32 cyc, low;
+
+	one_cycle = (unsigned long long)NSEC_PER_SEC * 1000ULL;
+	do_div(one_cycle, pwm_clk_rate);
+
+	tmp = period_ns * 1000ULL;
+	do_div(tmp, one_cycle);
+	do_div(tmp, div);
+	tmp -= 1;
+	cyc = (tmp << V2M_PWMCYC_SHIFT) & V2M_PWMCYC_MASK;
+
+	tmp3 = duty_ns * tmp;
+	do_div(tmp3, period_ns);
+	if (tmp < tmp3)
+		tmp2 = 0;
+	else
+		tmp2 = tmp - tmp3;
+
+	low = (tmp2 << V2M_PWMLOW_SHIFT) & V2M_PWMLOW_MASK;
+
+	/* Avoid prohibited setting */
+	if (cyc == 0)
+		return -EINVAL;
+
+	v2m_pwm_write(rp, cyc, V2M_PWMCYC);
+	v2m_pwm_write(rp, low, V2M_PWMLOW);
+	wait_time(rp, 6, 9); //leave a write interval of 6 * PCLK + 9 * PWM_CLK
+
+	return 0;
+}
+
+static int v2m_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	return pm_runtime_get_sync(chip->dev);
+}
+
+static void v2m_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	pm_runtime_put(chip->dev);
+}
+
+static int v2m_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			   int duty_ns, int period_ns)
+{
+	struct v2m_pwm_chip *rp = to_v2m_pwm_chip(chip);
+	int div, ret;
+
+	if (pwm_is_enabled(pwm)) {
+		dev_warn(chip->dev, "pwm is already enabled \n");
+		return 0;
+	}
+	dev_info(NULL, "%s Cycle setting function is entered.\n",__func__);
+	div = v2m_pwm_get_clock_division(rp, period_ns);
+	if (div < 0)
+		return div;
+
+	v2m_pwm_update(rp, V2M_PWMCTR_PWMTM, 0, V2M_PWMCTR);
+	ret = v2m_pwm_set_counter(rp, div, duty_ns, period_ns);
+
+	return ret;
+}
+
+static int v2m_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct v2m_pwm_chip *rp = to_v2m_pwm_chip(chip);
+	u32 value;
+
+	dev_info(NULL, "%s Interrupt enable function is entered.\n",__func__);
+
+	/* Don't enable the PWM device if V2M_PWMCYC is 0 */
+	value = v2m_pwm_read(rp, V2M_PWMCYC);
+	if ((value & V2M_PWMCYC_MASK) == 0)
+		return -EINVAL;
+
+	//set Interrupt enable at PWM clear counter edge
+	v2m_pwm_update(rp, V2M_PWMIEN_PWMEC, V2M_PWMIEN_PWMEC, V2M_PWMIEN);
+	v2m_pwm_update(rp, V2M_PWMCTR_PWME, V2M_PWMCTR_PWME, V2M_PWMCTR);
+	wait_time(rp, 6, 9); //leave a write interval of 6 * PCLK + 9 * PWM_CLK
+
+	return 0;
+}
+
+static void v2m_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct v2m_pwm_chip *rp = to_v2m_pwm_chip(chip);
+
+	dev_info(NULL, "%s Interrupt disable function is entered.\n",__func__);
+	
+	v2m_pwm_update(rp, V2M_PWMCTR_PWME, 0, V2M_PWMCTR);
+	v2m_pwm_update(rp, V2M_PWMIEN_PWMEC, 0, V2M_PWMIEN);
+	wait_time(rp, 6, 9); //leave a write interval of 6 * PCLK + 9 * PWM_CLK
+}
+
+static int v2m_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm, enum pwm_polarity polarity)
+{
+	struct v2m_pwm_chip *rp = to_v2m_pwm_chip(chip);
+
+	dev_info(NULL, "%s polarity function is entered.\n",__func__);
+	
+	if (polarity == PWM_POLARITY_NORMAL)
+	{
+		v2m_pwm_update(rp, V2M_PWMCTR_PWMHL, 0, V2M_PWMCTR);
+	}
+	else
+	{
+		v2m_pwm_update(rp, V2M_PWMCTR_PWMHL, V2M_PWMCTR_PWMHL, V2M_PWMCTR);
+	}
+	wait_time(rp, 6, 9); //leave a write interval of 6 * PCLK + 9 * PWM_CLK
+
+	return 0;
+}
+
+static const struct pwm_ops v2m_pwm_ops = {
+	.request = v2m_pwm_request,
+	.free = v2m_pwm_free,
+	.config = v2m_pwm_config,
+	.enable = v2m_pwm_enable,
+	.disable = v2m_pwm_disable,
+	.set_polarity = v2m_pwm_set_polarity,
+	.owner = THIS_MODULE,
+};
+
+static irqreturn_t v2m_pwm_interrupt(int irq, void *data)
+{
+	struct v2m_pwm_chip *rp = data;
+	u32 value;
+
+	value = v2m_pwm_read(rp, V2M_PWMINT);
+	if (value & V2M_PWMINT_PWMIC) {
+		v2m_pwm_update(rp, V2M_PWMINT_PWMIC, V2M_PWMINT_PWMIC, V2M_PWMINT);
+		wait_time(rp, 5, 5); //leave a write interval of 5 * PCLK + 5 * PWM_CLK
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int v2m_pwm_probe(struct platform_device *pdev)
+{
+	struct v2m_pwm_chip *v2m_pwm;
+	struct resource *res;
+	int ret, irq;
+
+	v2m_pwm = devm_kzalloc(&pdev->dev, sizeof(*v2m_pwm), GFP_KERNEL);
+	if (v2m_pwm == NULL)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	v2m_pwm->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(v2m_pwm->base))
+		return PTR_ERR(v2m_pwm->base);
+
+	v2m_pwm->sys_clk = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(v2m_pwm->sys_clk)) {
+		dev_err(&pdev->dev, "failed to get system clock\n");
+		return PTR_ERR(v2m_pwm->sys_clk);
+	}
+
+	v2m_pwm->pwm_clk = devm_clk_get(&pdev->dev, "pwm");
+	if (IS_ERR(v2m_pwm->pwm_clk)) {
+		dev_err(&pdev->dev, "failed to get pwm clock\n");
+		return PTR_ERR(v2m_pwm->pwm_clk);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "Failed to obtain IRQ\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, v2m_pwm_interrupt, 0, pdev->name, v2m_pwm);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to request IRQ\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, v2m_pwm);
+
+	v2m_pwm->chip.dev = &pdev->dev;
+	v2m_pwm->chip.ops = &v2m_pwm_ops;
+	v2m_pwm->chip.base = -1;
+	v2m_pwm->chip.npwm = 1;
+
+	ret = pwmchip_add(&v2m_pwm->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register PWM chip: %d\n", ret);
+		return ret;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+}
+
+static int v2m_pwm_remove(struct platform_device *pdev)
+{
+	struct v2m_pwm_chip *v2m_pwm = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	return pwmchip_remove(&v2m_pwm->chip);
+}
+
+static const struct of_device_id v2m_pwm_of_table[] = {
+	{ .compatible = "renesas,pwm-v2m", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, v2m_pwm_of_table);
+
+#ifdef CONFIG_PM_SLEEP
+static struct pwm_device *v2m_pwm_dev_to_pwm_dev(struct device *dev)
+{
+	struct v2m_pwm_chip *v2m_pwm = dev_get_drvdata(dev);
+	struct pwm_chip *chip = &v2m_pwm->chip;
+
+	return &chip->pwms[0];
+}
+
+static int v2m_pwm_suspend(struct device *dev)
+{
+	struct pwm_device *pwm = v2m_pwm_dev_to_pwm_dev(dev);
+
+	if (!test_bit(PWMF_REQUESTED, &pwm->flags))
+		return 0;
+
+	pm_runtime_put(dev);
+
+	return 0;
+}
+
+static int v2m_pwm_resume(struct device *dev)
+{
+	struct pwm_device *pwm = v2m_pwm_dev_to_pwm_dev(dev);
+	int ret;
+	if (!test_bit(PWMF_REQUESTED, &pwm->flags))
+		return 0;
+
+	pm_runtime_get_sync(dev);
+
+	ret = v2m_pwm_config(pwm->chip, pwm, pwm->state.duty_cycle,	pwm->state.period);
+	if (ret < 0)
+		return ret;
+
+	if (pwm_is_enabled(pwm))
+		ret = v2m_pwm_enable(pwm->chip, pwm);
+
+	return ret;
+}
+#endif /* CONFIG_PM_SLEEP */
+static SIMPLE_DEV_PM_OPS(v2m_pwm_pm_ops, v2m_pwm_suspend, v2m_pwm_resume);
+
+static struct platform_driver v2m_pwm_driver = {
+	.probe = v2m_pwm_probe,
+	.remove = v2m_pwm_remove,
+	.driver = {
+		.name = "pwm-v2m",
+		.pm	= &v2m_pwm_pm_ops,
+		.of_match_table = of_match_ptr(v2m_pwm_of_table),
+	}
+};
+module_platform_driver(v2m_pwm_driver);
+
+MODULE_AUTHOR("HoaPhan <hoa.phan.df@renesas.com>");
+MODULE_DESCRIPTION("Renesas PWM Timer Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:pwm-v2m");
