From 93232f6d07e392426f9dc93e00bd6199b98f53a2 Mon Sep 17 00:00:00 2001
From: Canh Dao <canh.dao.ct@renesas.com>
Date: Wed, 11 Aug 2021 08:50:29 +0700
Subject: [PATCH] tty serial 8250 renesas rzv2m

Signed-off-by: Canh Dao <canh.dao.ct@renesas.com>
---
 drivers/tty/serial/8250/8250_dma.c   |  8 ++++
 drivers/tty/serial/8250/8250_early.c | 25 +++++++++++
 drivers/tty/serial/8250/8250_of.c    |  8 ++++
 drivers/tty/serial/8250/8250_port.c  | 86 ++++++++++++++++++++++++++++++++++++
 4 files changed, 127 insertions(+)

diff --git a/drivers/tty/serial/8250/8250_dma.c b/drivers/tty/serial/8250/8250_dma.c
index bfa1a85..98f2dce 100644
--- a/drivers/tty/serial/8250/8250_dma.c
+++ b/drivers/tty/serial/8250/8250_dma.c
@@ -8,6 +8,9 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_reg.h>
 #include <linux/dma-mapping.h>
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+#include <linux/console.h>
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
 
 #include "8250.h"
 
@@ -50,6 +53,11 @@ static void __dma_rx_complete(void *param)
 	struct dma_tx_state	state;
 	int			count;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       if (!dma->rx_running)
+               return;
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	dma->rx_running = 0;
 	dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
 
diff --git a/drivers/tty/serial/8250/8250_early.c b/drivers/tty/serial/8250/8250_early.c
index 5cd8c36..0d9ea16 100644
--- a/drivers/tty/serial/8250/8250_early.c
+++ b/drivers/tty/serial/8250/8250_early.c
@@ -138,6 +138,31 @@ int __init early_serial8250_setup(struct earlycon_device *device,
 	if (!(device->port.membase || device->port.iobase))
 		return -ENODEV;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       {
+               struct uart_port *up = &device->port;
+               unsigned int ier, fcr, lcr, mcr, hcr0;
+
+               ier = serial8250_early_in(up, UART_IER);
+               fcr = serial8250_early_in(up, UART_FCR);
+               lcr = serial8250_early_in(up, UART_LCR);
+               mcr = serial8250_early_in(up, UART_MCR);
+               hcr0 = serial8250_early_in(up, UART_HCR0);
+
+               serial8250_early_out(up, UART_FCR,
+                       fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+
+               serial8250_early_out(up, UART_HCR0, hcr0 | UART_HCR0_SWRST);
+               serial8250_early_out(up, UART_HCR0, hcr0 & ~UART_HCR0_SWRST);
+
+               serial8250_early_out(up, UART_IER, ier);
+               serial8250_early_out(up, UART_FCR, fcr);
+               serial8250_early_out(up, UART_LCR, lcr);
+               serial8250_early_out(up, UART_MCR, mcr);
+               serial8250_early_out(up, UART_HCR0, hcr0);
+       }
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	if (!device->baud) {
 		struct uart_port *port = &device->port;
 		unsigned int ier;
diff --git a/drivers/tty/serial/8250/8250_of.c b/drivers/tty/serial/8250/8250_of.c
index 8fedc07..8b27465 100644
--- a/drivers/tty/serial/8250/8250_of.c
+++ b/drivers/tty/serial/8250/8250_of.c
@@ -248,6 +248,14 @@ static int of_platform_serial_probe(struct platform_device *ofdev)
 			&port8250.overrun_backoff_time_ms) != 0)
 		port8250.overrun_backoff_time_ms = 0;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+        if (of_find_property(ofdev->dev.of_node, "dmas", NULL)
+                && of_find_property(ofdev->dev.of_node,
+                                               "dma-names", NULL))
+                port8250.dma = devm_kzalloc(&ofdev->dev,
+                       sizeof(struct uart_8250_dma), GFP_KERNEL);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	ret = serial8250_register_8250_port(&port8250);
 	if (ret < 0)
 		goto err_dispose;
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index 60ca19e..2087492 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -114,6 +114,18 @@ static const struct serial8250_config uart_config[] = {
 		.rxtrig_bytes	= {8, 16, 24, 28},
 		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
 	},
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       [PORT_16750] = {
+               .name           = "R8ARZV2M16750",
+               .fifo_size      = 64,
+               .tx_loadsz      = 64,
+               .fcr            = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10 |
+                                 UART_FCR7_64BYTE | UART_FCR_DMA_SELECT,
+               .rxtrig_bytes   = {1, 16, 32, 56},
+               .flags          = UART_CAP_FIFO | UART_CAP_AFE,
+       },
+#else  /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	[PORT_16750] = {
 		.name		= "TI16750",
 		.fifo_size	= 64,
@@ -123,6 +135,7 @@ static const struct serial8250_config uart_config[] = {
 		.rxtrig_bytes	= {1, 16, 32, 56},
 		.flags		= UART_CAP_FIFO | UART_CAP_SLEEP | UART_CAP_AFE,
 	},
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
 	[PORT_STARTECH] = {
 		.name		= "Startech",
 		.fifo_size	= 1,
@@ -456,6 +469,9 @@ static void io_serial_out(struct uart_port *p, int offset, int value)
 }
 
 static int serial8250_default_handle_irq(struct uart_port *port);
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+static int fcr_get_rxtrig_bytes(struct uart_8250_port *up);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
 
 static void set_io_from_upio(struct uart_port *p)
 {
@@ -526,6 +542,33 @@ serial_port_out_sync(struct uart_port *p, int offset, int value)
 	}
 }
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+/*
+ * For the RZV2M
+ */
+static void serial8250_clear_internal_macro(struct uart_8250_port *up)
+{
+       unsigned int ier, fcr, lcr, mcr, hcr0;
+
+       ier = serial_in(up, UART_IER);
+       fcr = serial_in(up, UART_FCR);
+       lcr = serial_in(up, UART_LCR);
+       mcr = serial_in(up, UART_MCR);
+       hcr0 = serial_in(up, UART_HCR0);
+
+       serial_out(up, UART_FCR,
+               fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+       serial_out(up, UART_HCR0, hcr0 | UART_HCR0_SWRST);
+       serial_out(up, UART_HCR0, hcr0 & ~UART_HCR0_SWRST);
+
+       serial_out(up, UART_IER, ier);
+       serial_out(up, UART_FCR, fcr);
+       serial_out(up, UART_LCR, lcr);
+       serial_out(up, UART_MCR, mcr);
+       serial_out(up, UART_HCR0, hcr0);
+}
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 /*
  * For the 16C950
  */
@@ -1008,6 +1051,14 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	unsigned char status1, status2;
 	unsigned int iersave;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       if (IS_ENABLED(CONFIG_ARCH_R9A09G011GBG)) {
+               up->port.type = PORT_16750;
+               up->capabilities |= UART_CAP_FIFO | UART_CAP_AFE;
+               return;
+       }
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	up->port.type = PORT_16550A;
 	up->capabilities |= UART_CAP_FIFO;
 
@@ -1701,6 +1752,10 @@ void serial8250_read_char(struct uart_8250_port *up, unsigned char lsr)
 
 	port->icount.rx++;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+        lsr |= (serial_in(up, UART_LSR) & 0x9C);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	lsr |= up->lsr_saved_flags;
 	up->lsr_saved_flags = 0;
 
@@ -1999,6 +2054,9 @@ void serial8250_do_set_mctrl(struct uart_port *port, unsigned int mctrl)
 		mcr |= UART_MCR_OUT2;
 	if (mctrl & TIOCM_LOOP)
 		mcr |= UART_MCR_LOOP;
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+               serial8250_clear_internal_macro(up);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
 
 	mcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;
 
@@ -2132,6 +2190,10 @@ int serial8250_do_startup(struct uart_port *port)
 	unsigned char lsr, iir;
 	int retval;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       serial8250_clear_internal_macro(up);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	if (!port->fifosize)
 		port->fifosize = uart_config[port->type].fifo_size;
 	if (!up->tx_loadsz)
@@ -2389,6 +2451,13 @@ int serial8250_do_startup(struct uart_port *port)
 	 * Request DMA channels for both RX and TX.
 	 */
 	if (up->dma) {
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+                serial_port_out(port, UART_HCR0,
+                        serial_port_in(port, UART_HCR0) | UART_HCR0_RTDRD |
+                                UART_HCR0_RDE | UART_HCR0_TDE);
+                up->dma->rx_size = fcr_get_rxtrig_bytes(up);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 		retval = serial8250_request_dma(up);
 		if (retval) {
 			pr_warn_ratelimited("%s - failed to request DMA\n",
@@ -2460,9 +2529,13 @@ void serial8250_do_shutdown(struct uart_port *port)
 	/*
 	 * Disable break condition and FIFOs
 	 */
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+        serial8250_clear_internal_macro(up);
+#else  /* defined(CONFIG_ARCH_R9A09G011GBG) */
 	serial_port_out(port, UART_LCR,
 			serial_port_in(port, UART_LCR) & ~UART_LCR_SBC);
 	serial8250_clear_fifos(up);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
 
 #ifdef CONFIG_SERIAL_8250_RSA
 	/*
@@ -2667,6 +2740,10 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 	unsigned long flags;
 	unsigned int baud, quot, frac = 0;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       serial8250_clear_internal_macro(up);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	if (up->capabilities & UART_CAP_MINI) {
 		termios->c_cflag &= ~(CSTOPB | PARENB | PARODD | CMSPAR);
 		if ((termios->c_cflag & CSIZE) == CS5 ||
@@ -2704,6 +2781,11 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 		up->mcr &= ~UART_MCR_AFE;
 		if (termios->c_cflag & CRTSCTS)
 			up->mcr |= UART_MCR_AFE;
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+                       serial_port_out(port, UART_HCR0,
+                               serial_port_in(port, UART_HCR0) |
+                               UART_HCR0_RM);
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
 	}
 
 	/*
@@ -3334,6 +3416,10 @@ int serial8250_console_setup(struct uart_port *port, char *options, bool probe)
 	if (!port->iobase && !port->membase)
 		return -ENODEV;
 
+#if defined(CONFIG_ARCH_R9A09G011GBG)
+       serial8250_clear_internal_macro(up_to_u8250p(port));
+#endif /* defined(CONFIG_ARCH_R9A09G011GBG) */
+
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
 	else if (probe)
-- 
2.7.4

