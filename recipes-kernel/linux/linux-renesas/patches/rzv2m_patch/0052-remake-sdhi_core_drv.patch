diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
index bbfeeff..6b45bdc 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
@@ -212,8 +212,7 @@
         };
         
         sdhi0: sd@85000000 {    /* used sh card boot */
-            compatible = "renesas,sdhi-r8a774c0",
-                     "renesas,rcar-gen3-sdhi";
+            compatible = "renesas,rzv2m-sdhi";
             reg = <0 0x85000000 0 0x2000>;
             interrupts = <GIC_SPI 356 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 357 IRQ_TYPE_LEVEL_HIGH>;
             clocks = <&cpg CPG_MOD 301>;
@@ -226,8 +225,7 @@
         };
         
         eMM: sd@85020000 {
-            compatible = "renesas,sdhi-r8a774c0",
-                    "renesas,rcar-gen3-sdhi";
+            compatible = "renesas,rzv2m-sdhi";
             reg = <0 0x85020000 0 0x2000>;
             interrupts = <GIC_SPI 354 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 355 IRQ_TYPE_LEVEL_HIGH>;
             clocks = <&cpg CPG_MOD 309>;
diff --git a/drivers/mmc/host/renesas_sdhi_core.c b/drivers/mmc/host/renesas_sdhi_core.c
index 5ee89b2..b197b91 100755
--- a/drivers/mmc/host/renesas_sdhi_core.c
+++ b/drivers/mmc/host/renesas_sdhi_core.c
@@ -32,10 +32,7 @@
 #include <linux/mfd/tmio.h>
 #include <linux/sh_dma.h>
 #include <linux/delay.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/pinctrl/pinctrl-state.h>
 #include <linux/regulator/consumer.h>
-#include <linux/sys_soc.h>
 
 #include "renesas_sdhi.h"
 #include "tmio_mmc.h"
@@ -53,7 +50,14 @@
 #define B2REG_PSC_BASE_ADDR     (0x00000000A3700000ULL)
 #define B2REG_PSC_SDSEL_OFSET   (0x0080)
 
-#define MAX_CHIP_NAME_SIZE 	(20)
+#define RZV2M_DEVICE_NAME_SD0  "85000000.sd"
+#define RZV2M_DEVICE_NAME_SD1  "85010000.sd"
+#define RZV2M_DEVICE_NAME_EMMC "85020000.sd"
+
+
+#define PSC_SEL_SD0			(0)  //SD0 select
+#define PSC_SEL_SD1			(1)  //SD1 select
+
 #define	PSC_REG_SD_3_3V		(0)
 #define	PSC_REG_SD_1_8V		(1)
 
@@ -61,15 +65,9 @@
 
 enum switching_voltage_mode{
 	psc_mode,
-	pfc_mode,
 	none,
 };
 
-static const struct soc_device_attribute soc_whitelist[] = {
-	{ .soc_id = "r8arzv2m" },
-	{ /* sentinel */ }
-};
-
 static int psc_voltage_switch(uint32_t pins, uint8_t voltage)
 {
 	
@@ -88,8 +86,6 @@ static int psc_voltage_switch(uint32_t pins, uint8_t voltage)
 	return 0;
 }
 
-
-
 static void renesas_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 {
 	u32 val;
@@ -218,38 +214,9 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 {
 	struct tmio_mmc_host *host = mmc_priv(mmc);
 	struct renesas_sdhi *priv = host_to_priv(host);
-	struct pinctrl_state *pin_state;
-	int ret;
 	u8 psc_state;
 	
-	if(priv->switching_volt_type == pfc_mode){
-		switch (ios->signal_voltage) {
-		case MMC_SIGNAL_VOLTAGE_330:
-			pin_state = priv->pins_default;
-			break;
-		case MMC_SIGNAL_VOLTAGE_180:
-			pin_state = priv->pins_uhs;
-			break;
-		default:
-			return -EINVAL;
-		}
-
-		/*
-		 * If anything is missing, assume signal voltage is fixed at
-		 * 3.3V and succeed/fail accordingly.
-		 */
-		if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
-			return ios->signal_voltage ==
-				MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
-
-		ret = mmc_regulator_set_vqmmc(host->mmc, ios);
-		if (ret)
-			return ret;
-
-		return pinctrl_select_state(priv->pinctrl, pin_state);
-	}
-	
-	else if(priv->switching_volt_type == psc_mode){
+	if(priv->switching_volt_type == psc_mode){
 		switch (ios->signal_voltage) {
 		case MMC_SIGNAL_VOLTAGE_330:
 				psc_state = PSC_REG_SD_3_3V;
@@ -262,6 +229,10 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 		}
 		return psc_voltage_switch(priv->psc_pins, psc_state);
 	}
+	else{
+		//The voltage of eMMC is fixed at 1.8V.
+	}
+	
 	return 0;
 }
 
@@ -660,37 +631,20 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	 * If the soc_device_match finds a soc_id, it run power slaveport control mode.
 	 * If you use pin function control unit, do not write a soc_id to whitelist.
 	 */
-	
-	const struct soc_device_attribute *soc = soc_device_match(soc_whitelist);
-	
-	if (soc){
+	if (strncmp(pdev->name, RZV2M_DEVICE_NAME_SD0, strlen(RZV2M_DEVICE_NAME_SD0)) == 0) {
+		priv->psc_pins = PSC_SEL_SD0;
 		priv->switching_volt_type = psc_mode;
-			
-		if(of_property_read_u32(pdev->dev.of_node, "psc-pins", &psc_pins)){
-			priv->psc_pins = psc_pins;
-
-			if(   16 <= priv->psc_pins ){
-				return -EINVAL;
-			}
-		}
-		else
-		{
-			priv->switching_volt_type = none;
-		}
 	}
-	else
-		priv->switching_volt_type = pfc_mode;
-		
-	if(priv->switching_volt_type == pfc_mode){
-		priv->pinctrl = devm_pinctrl_get(&pdev->dev);
-		if (!IS_ERR(priv->pinctrl)) {
-			priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
-							PINCTRL_STATE_DEFAULT);
-			priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
-							"state_uhs");
-		}
+	else if (strncmp(pdev->name, RZV2M_DEVICE_NAME_SD1, strlen(RZV2M_DEVICE_NAME_SD1)) == 0) {
+		priv->psc_pins = PSC_SEL_SD1;
+		priv->switching_volt_type = psc_mode;
+	}
+	else{
+		//The voltage of eMMC is fixed at 1.8V.
+		priv->switching_volt_type = none;
 	}
-		
+
+	
 	host = tmio_mmc_host_alloc(pdev, mmc_data);
 	if (IS_ERR(host))
 		return PTR_ERR(host);
diff --git a/drivers/mmc/host/renesas_sdhi_internal_dmac.c b/drivers/mmc/host/renesas_sdhi_internal_dmac.c
index 6eba4ae..d5c1dab 100755
--- a/drivers/mmc/host/renesas_sdhi_internal_dmac.c
+++ b/drivers/mmc/host/renesas_sdhi_internal_dmac.c
@@ -119,6 +119,7 @@ static const struct of_device_id renesas_sdhi_internal_dmac_of_match[] = {
 	{ .compatible = "renesas,sdhi-r8a7795", .data = &of_rcar_r8a7795_compatible, },
 	{ .compatible = "renesas,sdhi-r8a7796", .data = &of_rcar_r8a7795_compatible, },
 	{ .compatible = "renesas,rcar-gen3-sdhi", .data = &of_rcar_gen3_compatible, },
+	{ .compatible = "renesas,rzv2m-sdhi", .data = &of_rcar_gen3_compatible, },
 	{},
 };
 MODULE_DEVICE_TABLE(of, renesas_sdhi_internal_dmac_of_match);
