diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
index 0c20f17..376b24c 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
@@ -168,6 +168,7 @@
 };
 
 &sdhi0 {
+	psc-pins = <0>;
     status = "okay";
 };
 
diff --git a/drivers/mmc/host/renesas_sdhi.h b/drivers/mmc/host/renesas_sdhi.h
index f13f798..7efad11 100755
--- a/drivers/mmc/host/renesas_sdhi.h
+++ b/drivers/mmc/host/renesas_sdhi.h
@@ -52,6 +52,8 @@ struct renesas_sdhi {
 	struct pinctrl_state *pins_default, *pins_uhs;
 	void __iomem *scc_ctl;
 	u32 scc_tappos;
+	u32 psc_pins;
+	u8  switching_volt_type;
 };
 
 #define host_to_priv(host) \
diff --git a/drivers/mmc/host/renesas_sdhi_core.c b/drivers/mmc/host/renesas_sdhi_core.c
index 45baf5d..c414f22 100755
--- a/drivers/mmc/host/renesas_sdhi_core.c
+++ b/drivers/mmc/host/renesas_sdhi_core.c
@@ -35,6 +35,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/pinctrl/pinctrl-state.h>
 #include <linux/regulator/consumer.h>
+#include <linux/sys_soc.h>
 
 #include "renesas_sdhi.h"
 #include "tmio_mmc.h"
@@ -48,6 +49,46 @@
 #define SDHI_VER_GEN3_SD	0xcc10
 #define SDHI_VER_GEN3_SDMMC	0xcd10
 
+
+#define B2REG_PSC_BASE_ADDR     (0x00000000A3700000ULL)
+#define B2REG_PSC_SDSEL_OFSET   (0x0080)
+
+#define MAX_CHIP_NAME_SIZE 	(20)
+#define	PSC_REG_SD_3_3V		(0)
+#define	PSC_REG_SD_1_8V		(1)
+
+
+
+enum switching_voltage_mode{
+	psc_mode,
+	pfc_mode,
+};
+
+static const struct soc_device_attribute soc_whitelist[] = {
+	{ .soc_id = "r8arzv2m" },
+	{ /* sentinel */ }
+};
+
+static int psc_voltage_switch(uint32_t pins, uint8_t voltage)
+{
+	
+    uint32_t data;
+	void __iomem * remap_addr;
+	
+	remap_addr = ioremap(B2REG_PSC_BASE_ADDR,sizeof(*remap_addr));
+	if (!remap_addr) {
+        return -EINVAL;
+    }
+	
+	data = (voltage << pins) | BIT((pins+16));
+	writel(data , remap_addr + B2REG_PSC_SDSEL_OFSET);	
+	iounmap(remap_addr);
+
+	return 0;
+}
+
+
+
 static void renesas_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 {
 	u32 val;
@@ -178,31 +219,48 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 	struct renesas_sdhi *priv = host_to_priv(host);
 	struct pinctrl_state *pin_state;
 	int ret;
+	u8 psc_state;
+	
+	if(priv->switching_volt_type == pfc_mode){
+		switch (ios->signal_voltage) {
+		case MMC_SIGNAL_VOLTAGE_330:
+			pin_state = priv->pins_default;
+			break;
+		case MMC_SIGNAL_VOLTAGE_180:
+			pin_state = priv->pins_uhs;
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	switch (ios->signal_voltage) {
-	case MMC_SIGNAL_VOLTAGE_330:
-		pin_state = priv->pins_default;
-		break;
-	case MMC_SIGNAL_VOLTAGE_180:
-		pin_state = priv->pins_uhs;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/*
-	 * If anything is missing, assume signal voltage is fixed at
-	 * 3.3V and succeed/fail accordingly.
-	 */
-	if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
-		return ios->signal_voltage ==
-			MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
+		/*
+		 * If anything is missing, assume signal voltage is fixed at
+		 * 3.3V and succeed/fail accordingly.
+		 */
+		if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
+			return ios->signal_voltage ==
+				MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
 
-	ret = mmc_regulator_set_vqmmc(host->mmc, ios);
-	if (ret)
-		return ret;
+		ret = mmc_regulator_set_vqmmc(host->mmc, ios);
+		if (ret)
+			return ret;
 
-	return pinctrl_select_state(priv->pinctrl, pin_state);
+		return pinctrl_select_state(priv->pinctrl, pin_state);
+	}
+	
+	else if(priv->switching_volt_type == psc_mode){
+		switch (ios->signal_voltage) {
+		case MMC_SIGNAL_VOLTAGE_330:
+				psc_state = PSC_REG_SD_3_3V;
+			break;
+		case MMC_SIGNAL_VOLTAGE_180:
+				psc_state = PSC_REG_SD_1_8V;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return psc_voltage_switch(priv->psc_pins, psc_state);
+	}
 }
 
 /* SCC registers */
@@ -558,6 +616,7 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	struct resource *res;
 	int irq, ret, i;
 	u16 ver;
+	u32 psc_pins = 0;
 
 	of_data = of_device_get_match_data(&pdev->dev);
 
@@ -595,14 +654,41 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	if (IS_ERR(priv->clk_cd))
 		priv->clk_cd = NULL;
 
-	priv->pinctrl = devm_pinctrl_get(&pdev->dev);
-	if (!IS_ERR(priv->pinctrl)) {
-		priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
-						PINCTRL_STATE_DEFAULT);
-		priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
-						"state_uhs");
-	}
+	/* Voltage switching type depends on the soc_id.
+	 * If the soc_device_match finds a soc_id, it run power slaveport control mode.
+	 * If you use pin function control unit, do not write a soc_id to whitelist.
+	 */
+	
+	const struct soc_device_attribute *soc = soc_device_match(soc_whitelist);
+	
+	if (soc){
+		priv->switching_volt_type = psc_mode;
+			
+		if(of_property_read_u32(pdev->dev.of_node, "psc-pins", &psc_pins))
+			priv->switching_volt_type = pfc_mode;
 
+		else
+		{
+			priv->psc_pins = psc_pins;
+
+			if(   32 <= priv->psc_pins ){
+				return -EINVAL;
+			}
+		}
+	}
+	else
+		priv->switching_volt_type = pfc_mode;
+		
+	if(priv->switching_volt_type == pfc_mode){
+		priv->pinctrl = devm_pinctrl_get(&pdev->dev);
+		if (!IS_ERR(priv->pinctrl)) {
+			priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
+							PINCTRL_STATE_DEFAULT);
+			priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
+							"state_uhs");
+		}
+	}
+		
 	host = tmio_mmc_host_alloc(pdev, mmc_data);
 	if (IS_ERR(host))
 		return PTR_ERR(host);
