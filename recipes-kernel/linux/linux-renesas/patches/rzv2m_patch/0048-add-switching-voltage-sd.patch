From edb22711777c12f39c30cba6030d69ec45a53b61 Mon Sep 17 00:00:00 2001
From: Canh Dao <canh.dao.ct@renesas.com>
Date: Fri, 20 Aug 2021 16:41:08 +0700
Subject: [PATCH] add switching voltage sd

Signed-off-by: Canh Dao <canh.dao.ct@renesas.com>
---
 .../dts/renesas/r9a09g011gbg-evaluation-board.dts  |   1 +
 drivers/mmc/host/renesas_sdhi.h                    |   2 +
 drivers/mmc/host/renesas_sdhi_core.c               | 149 ++++++++++++++++-----
 3 files changed, 120 insertions(+), 32 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
index 51437e7..967c723 100755
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
@@ -169,6 +169,7 @@
 };
 
 &sdhi0 {
+       psc-pins = <0>;
     status = "okay";
 };
 
diff --git a/drivers/mmc/host/renesas_sdhi.h b/drivers/mmc/host/renesas_sdhi.h
index 1b1ce5e..9d52093 100644
--- a/drivers/mmc/host/renesas_sdhi.h
+++ b/drivers/mmc/host/renesas_sdhi.h
@@ -64,6 +64,8 @@ struct renesas_sdhi {
 	struct pinctrl_state *pins_default, *pins_uhs;
 	void __iomem *scc_ctl;
 	u32 scc_tappos;
+        u32 psc_pins;
+        u8  switching_volt_type;
 	u32 scc_tappos_hs400;
 	bool doing_tune;
 	bool dtranend1_bit17;
diff --git a/drivers/mmc/host/renesas_sdhi_core.c b/drivers/mmc/host/renesas_sdhi_core.c
index e5a989c..a9d3985 100644
--- a/drivers/mmc/host/renesas_sdhi_core.c
+++ b/drivers/mmc/host/renesas_sdhi_core.c
@@ -36,6 +36,7 @@
 #include <linux/pinctrl/pinctrl-state.h>
 #include <linux/regulator/consumer.h>
 #include <linux/sys_soc.h>
+#include <linux/sys_soc.h>
 
 #include "renesas_sdhi.h"
 #include "tmio_mmc.h"
@@ -49,6 +50,45 @@
 #define SDHI_VER_GEN3_SD	0xcc10
 #define SDHI_VER_GEN3_SDMMC	0xcd10
 
+#define B2REG_PSC_BASE_ADDR     (0x00000000A3700000ULL)
+#define B2REG_PSC_SDSEL_OFSET   (0x0080)
+
+#define MAX_CHIP_NAME_SIZE     (20)
+#define        PSC_REG_SD_3_3V         (0)
+#define        PSC_REG_SD_1_8V         (1)
+
+
+
+enum switching_voltage_mode{
+       psc_mode,
+       pfc_mode,
+};
+
+static const struct soc_device_attribute soc_whitelist[] = {
+       { .soc_id = "r8arzv2m" },
+       { /* sentinel */ }
+};
+
+static int psc_voltage_switch(uint32_t pins, uint8_t voltage)
+{
+
+    uint32_t data;
+       void __iomem * remap_addr;
+
+       remap_addr = ioremap(B2REG_PSC_BASE_ADDR,sizeof(*remap_addr));
+       if (!remap_addr) {
+        return -EINVAL;
+    }
+
+       data = (voltage << pins) | BIT((pins+16));
+       writel(data , remap_addr + B2REG_PSC_SDSEL_OFSET);
+       iounmap(remap_addr);
+
+       return 0;
+}
+
+
+
 static void renesas_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 {
 	u32 val;
@@ -179,31 +219,48 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 	struct renesas_sdhi *priv = host_to_priv(host);
 	struct pinctrl_state *pin_state;
 	int ret;
-
-	switch (ios->signal_voltage) {
-	case MMC_SIGNAL_VOLTAGE_330:
-		pin_state = priv->pins_default;
-		break;
-	case MMC_SIGNAL_VOLTAGE_180:
-		pin_state = priv->pins_uhs;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/*
-	 * If anything is missing, assume signal voltage is fixed at
-	 * 3.3V and succeed/fail accordingly.
-	 */
-	if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
-		return ios->signal_voltage ==
-			MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
-
-	ret = mmc_regulator_set_vqmmc(host->mmc, ios);
-	if (ret)
-		return ret;
-
-	return pinctrl_select_state(priv->pinctrl, pin_state);
+       u8 psc_state;
+
+       if(priv->switching_volt_type == pfc_mode){
+               switch (ios->signal_voltage) {
+               case MMC_SIGNAL_VOLTAGE_330:
+                       pin_state = priv->pins_default;
+                       break;
+               case MMC_SIGNAL_VOLTAGE_180:
+                       pin_state = priv->pins_uhs;
+                       break;
+               default:
+                       return -EINVAL;
+               }
+
+               /*
+                * If anything is missing, assume signal voltage is fixed at
+                * 3.3V and succeed/fail accordingly.
+                */
+               if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
+                       return ios->signal_voltage ==
+                               MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
+
+               ret = mmc_regulator_set_vqmmc(host->mmc, ios);
+               if (ret)
+                       return ret;
+
+               return pinctrl_select_state(priv->pinctrl, pin_state);
+       }
+
+       else if(priv->switching_volt_type == psc_mode){
+               switch (ios->signal_voltage) {
+               case MMC_SIGNAL_VOLTAGE_330:
+                               psc_state = PSC_REG_SD_3_3V;
+                       break;
+               case MMC_SIGNAL_VOLTAGE_180:
+                               psc_state = PSC_REG_SD_1_8V;
+                       break;
+               default:
+                       return -EINVAL;
+               }
+               return psc_voltage_switch(priv->psc_pins, psc_state);
+       }
 }
 
 /* SCC registers */
@@ -852,6 +909,7 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	struct resource *res;
 	int irq, ret, i;
 	u16 ver;
+        u32 psc_pins = 0;
 	int port_num_offset = 0;
 
 	of_data = of_device_get_match_data(&pdev->dev);
@@ -895,13 +953,40 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	if (IS_ERR(priv->clk_cd))
 		priv->clk_cd = NULL;
 
-	priv->pinctrl = devm_pinctrl_get(&pdev->dev);
-	if (!IS_ERR(priv->pinctrl)) {
-		priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
-						PINCTRL_STATE_DEFAULT);
-		priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
-						"state_uhs");
-	}
+       /* Voltage switching type depends on the soc_id.
+        * If the soc_device_match finds a soc_id, it run power slaveport control mode.
+        * If you use pin function control unit, do not write a soc_id to whitelist.
+        */
+
+       const struct soc_device_attribute *soc = soc_device_match(soc_whitelist);
+
+       if (soc){
+               priv->switching_volt_type = psc_mode;
+
+               if(of_property_read_u32(pdev->dev.of_node, "psc-pins", &psc_pins))
+                       priv->switching_volt_type = pfc_mode;
+
+               else
+               {
+                       priv->psc_pins = psc_pins;
+
+                       if(   32 <= priv->psc_pins ){
+                               return -EINVAL;
+                       }
+               }
+       }
+       else
+               priv->switching_volt_type = pfc_mode;
+
+       if(priv->switching_volt_type == pfc_mode){
+               priv->pinctrl = devm_pinctrl_get(&pdev->dev);
+               if (!IS_ERR(priv->pinctrl)) {
+                       priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
+                                                       PINCTRL_STATE_DEFAULT);
+                       priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
+                                                       "state_uhs");
+               }
+       }
 
 	host = tmio_mmc_host_alloc(pdev, mmc_data);
 	if (IS_ERR(host))
-- 
2.7.4

